---
title: '**Introduction to Statistical Modelling in `R`**'
author: "Dae-Jin Lee < dlee@bcamath.org >"
date: '**CHAPTER 1. Introduction to `R` language**'
output:
  html_document:
    highlight: haddock
    theme: cerulean
    toc: yes
    toc_float:
      collapsed: yes
      smooth_scroll: yes
  pdf_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 5
    highlight: tango
    includes:
      in_header: mystyle.sty
    keep_tex: yes
    number_sections: yes
    template: introSM_template.tex
    toc: yes
    toc_depth: 2
  word_document: default
header-includes:
- \usepackage{hyperref}
- \usepackage{palatino}
- \usepackage{mathtools}
subtitle: BCAM - Basque Center for Applied Mathematics, Applied Statistics
bibliography: MMrefs.bib
---

***********

# Introduction to the `R` language


## Installing `R`

- Latest version of `R`. Download it [here](https://cran.r-project.org/)

### RStudio environment

- Rstudio is a user-friendly interface. Download it [here](https://www.rstudio.com/products/rstudio/download/) **Highly recommended!!!**


## Start with `R`

* Get current working directory 

```{r,eval=FALSE}
getwd() 
```

* list the objects in the current workspace

```{r,eval=FALSE}
ls()
```

* Set working directory

```{r, eval=FALSE}
setwd("/Users/dlee") 
```

* work with your previous commands

```{r,eval=FALSE}
history() # display last 25 commands
history(max.show=Inf) # display all previous commands
```


* save your command history

```{r,eval=FALSE}
savehistory(file="myfile") # default is ".Rhistory"
```

* recall your command history

```{r,eval=FALSE}
loadhistory(file="myfile") # default is ".Rhistory"
```


* save the workspace to the file `.RData` 

```{r, eval=FALSE}
save.image()
```

* save specific objects to a file  if you don't specify the path, the cwd is assumed

```{r,eval=FALSE}
save(<object list>,file="myfile.RData") 
```


* load a workspace into the current session

```{r,eval=FALSE}
load("myfile.RData") 
```


* quit `R`. You will be prompted to save the workspace. 

```{r,eval=FALSE}
q()
```


## Install and load an `R` library
 
```{r,eval=FALSE}
install.packages("DAAG") # (Data Analysis And Graphics)
```

or several packages 

```{r,eval=FALSE}
install.packages(c("DAAG","HSAUR2","Hmisc","psych","foreign","xlsx"))
```


In Rstudio (go to `package` and click `Install`)



Once installed the package, load it
```{r,warning=FALSE,message=FALSE}
library(DAAG) # or require(DAAG)
```
 
-------------------------------------

## Reading data

The `R` console


```{r}
x <- c(7.82,8.00,7.95) # c means "combine"
x
```

A quicker way is to use `scan()`

```{r,eval=FALSE}
x <- scan()  # enter a number followed by return and blank line to end
1: 7.82
2: 8.00
3: 7.95
4: 
Read 3 items
```
To create a character vector use `""`

```{r}
id <- c("John","Paul","George","Ringo")
```


To read a character vector 
```{r,eval=FALSE}
id <- scan(,"")
1: John
2: Paul
3: George
4: Ringo
5: 
Read 4 items  
```

```{r}
id
```


## Data Import

In most situations, we need to read data from a separate data file. There are several methods for doing this. 

* `scan()` (see `?scan` for help)


```{r}
cat("Example:", "2 3 5 7", "11 13 17", file = "ex.txt", sep = "\n") # creates ex.txt
scan("ex.txt", skip = 1)
scan("ex.txt", skip = 1, nlines = 1) # only 1 line after the skipped one
unlink("ex.data") # tidy up
```

* Several formats are available (`.txt`, `.csv`, `.xls`, `.xlsx`, `SAS`, `Stata`, etc...)

* Some `R` libraries to import data are 

```{r,message=FALSE,warning=FALSE}
library(gdata)
library(foreign)
``` 

\bigskip

* Read data from a `.txt` or `.csv` files

Create a folder, name it `data` and download `cars` data ([cardata.zip](data/cardata.zip))


```{r,eval=FALSE}
mydata1 = read.table("data/cardata.txt") 
mydata2 = read.csv("data/cardata.csv")  
```

* Other formats `.xls` and `.xlsx`

```{r,eval=FALSE,message=FALSE,warning=FALSE}
library(gdata)
mydata3 = read.xls("data/cardata.xls", sheet = 1, header = TRUE)

library(xlsx)
mydata4 = read.xlsx("data/cardata.xlsx", sheetIndex = 1, header = TRUE,colClasses=NA)
```

---------------------------------


* Minitab, SPSS, SAS or Stata

```{r, eval=FALSE, message=FALSE}
library(foreign)                   
mydata = read.mtp("mydata.mtp")  # Minitab
mydata = read.spss("myfile", to.data.frame=TRUE) # SPSS
mydata = read.dta("mydata.dta") # Stata
```

* Or
```{r,eval=FALSE}
library(Hmisc)
mydata = spss.get("mydata.por", use.value.labels=TRUE)  # SPSS
```

-------------------------

## Exporting data

* There are numerous methods for exporting `R` objects into other formats. For SPSS, SAS and Stata. you will need to load the `foreign` packages. For Excel, you will need the `xlsx` package.  
 
 - Tab-delimited text file

```{r,eval=FALSE}
mtcars
?mtcars    
write.table(mtcars, "cardata.txt", sep="\t") 
```

*  Excel spreadsheet

```{r,eval=FALSE}
library(xlsx)
write.xlsx(mydata, "mydata.xlsx")
```


----------------------------

## Data vectors

* Download `R code` [here](http://idaejin.github.io/bcam-courses/rbasics/rbasics.R)

* Create a vector of weights and heights

```{r}
weight<-c(60,72,57,90,95,72)  
class(weight)
height<-c(1.75,1.80,1.65,1.90,1.74,1.91)
```

* calculate Body Mass Index
```{r} 
bmi<- weight/height^2
bmi
```

----------------------------


## Basic statistics 

* mean, median, st dev, variance

```{r,eval=FALSE}
mean(weight) 
median(weight)
sd(weight)
var(weight)
```

* summarize data

```{r}
summary(weight)
```

* or

```{r,eval=FALSE}
min(weight)
max(weight)
range(weight)
sum(weight)
length(weight)
```

* Quantiles and percentile

There are several quartiles of an observation variable. The first quartile, or lower quartile, is the value that cuts off the first 25% of the data when it is sorted in ascending order. The second quartile, or median, is the value that cuts off the first 50%. The third quartile, or upper quartile, is the value that cuts off the first 75%. 

```{r}
quantile(weight)
```

The $n^{\rm th}$ percentile of an observation variable is the value that cuts off the first $n$ percent of the data values when it is sorted in ascending order. 

```{r}
quantile(weight,c(0.32,0.57,0.98))
```

* Covariance and correlation 


The *covariance* of two variables $x$ and $y$ in a data sample measures how the two are linearly related. A positive covariance would indicate a positive linear relationship between the variables, and a negative covariance would indicate the opposite.


$$
\rm{Cov}(x,y) = \frac{1}{n}\sum_{i=1}^{n}(x_i - \bar{x})(y_i - \bar{y})
$$

```{r}
cov(weight,height)
```
The *correlation coefficient* of two variables in a data sample is their covariance divided by the product of their standard deviations. It is a normalised measurement of how the two are linearly related.

Formally, the sample correlation coefficient is defined by the following formula, where $\sigma_x$ and $\sigma_y$ are the sample standard deviations, and $\sigma_xy$ is the covariance. 

$$
      \rho_{xy}  = \frac{\sigma_{xy}}{\sigma_x~\sigma_y}
$$

```{r}
cor(weight,height)
```

# Creating your own functions in `R`

One of the great strengths of `R` is the user's ability to add functions. In fact, many of the functions in `R` are actually functions of functions. The structure of a function is given below.

```{r,eval=FALSE}
myfunction <- function(arg1, arg2, ... ){
  statements
return(object)
}
```

```{r}
f <- function(x){
  x^2
    }
f
```

*Example:*
```{r}
# Given a number
f(2)
# Given a vector
x <- c(1,2,-4,7)
f(x)
```

Let us create a function that returns a set of summary statistics given a numeric vector:

```{r}
mysummary <- function(x){
  mean <- sum(x)/length(x)
   var <- var(x)
    sd <- sd(x)
 range <- range(x)
 result <- list(mean=mean,var=var,sd=sd,range=range)
 return(result)
}
```

Then
```{r}
set.seed(1234)
x <- rnorm(10)
stats <- mysummary(x)
stats
```

## Character vectors and factor variables

```{r}
subject <- c("John","Peter","Chris","Tony","Mary","Jane")
sex <- c("MALE","MALE","MALE","MALE","FEMALE","FEMALE")
class(subject)
table(sex)
```


-----------------------------------


## Data frames
```{r}
Dat <- data.frame(subject,sex,weight,height)
# add bmi to Dat
Dat$bmi <- bmi  # or Dat$bmi <- weight/height^2
class(Dat)
str(Dat) # display object structure
```


```{r}
# Change rownames
rownames(Dat)<-c("A","B","C","D","E","F")

# Access to data frame elements (similar to a matrix)
Dat[,1]     # 1st column
Dat[,1:3]   # 1st to 3rd columns
Dat[1:2,]   # 1st to 2nd row
```


## Working with data frames

**Example: Analyze data by groups**

*  Obtain the mean weight, height and BMI means by FEMALES and MALES:

1. Select each group and compute the mean

```{r, results='hide'}
Dat[sex=="MALE",]
Dat[sex=="FEMALE",]

mean(Dat[sex=="MALE",3])  # weight average of MALEs
mean(Dat[sex=="MALE","weight"])
```

2. Use `apply` by columns 
```{r, results='hide'}
apply(Dat[sex=="FEMALE",3:5],2,mean)
apply(Dat[sex=="MALE",3:5],2,mean)

# we can use apply with our own function
apply(Dat[sex=="FEMALE",3:5],2,function(x){x+2})
```

3. `by` and `colMeans`

```{r, results='hide'}
# 'by' splits your data by factors and do calculations on each subset.
by(Dat[,3:5],sex, colMeans) 
```

4. `aggregate`

```{r, results='hide'}
# another option
aggregate(Dat[,3:5], by=list(sex),mean) 
```

------------------------------------

## Logical vectors

* Choose individuals with `BMI>22`
```{r,results='hide'}
bmi
bmi>22
as.numeric(bmi>22) # convert a logical condition to a numeric value 0/1
which(bmi>22)  # gives the position of bmi for which bmi>22
```

* Which are between $20$ and $25$?

```{r,results='hide'}
bmi > 20 & bmi < 25
which(bmi > 20 & bmi < 25)
```

--------------------------------------

## Working with vectors 

* Concatenate

```{r,results='hide'}
x <- c(2, 3, 5, 2, 7, 1)
y <- c(10, 15, 12)
z <- c(x,y)  # concatenates x and y
```

* list two vectors

```{r}
zz <- list(x,y) # create a list
unlist(zz) # unlist the list converting it to a concatenated vector
``` 

* subset of vectors

```{r}
x[c(1,3,4)]

x[-c(2,6)] # negative subscripts omit the chosen elements 
```

* Sequences
```{r}
seq(1,9) # or 1:9
seq(1,9,by=1)
seq(1,9,by=0.5)
seq(1,9,length=20)
```

* Replicates

```{r,results='hide'}
oops <- c(7,9,13)
rep(oops,3) # repeats the entire vector "oops" three times
rep(oops,1:3) # this function has the number 3 replaced 
              #  by a vector with the three values (1,2,3) 
              #  indicating that 7 should be repeated once, 9 twice and 13 three times.

rep(c(2,3,5), 4)
rep(1:2,c(10,15))

rep(c("MALE","FEMALE"),c(4,2)) # it also works with character vectors 
c(rep("MALE",3), rep("FEMALE",2))
```

---------------------------------------------


## Matrices and arrays

```{r}
x<- 1:12
x
dim(x)<-c(3,4)  # 3 rows and 4 columns

X <- matrix(1:12,nrow=3,byrow=TRUE)
X

X <- matrix(1:12,nrow=3,byrow=FALSE)
X

# rownames, colnames

rownames(X) <- c("A","B","C")
X
colnames(X) <- LETTERS[4:7]
X
colnames(X) <- month.abb[4:7]
X
```

* Column/Row bind operations `cbind()`, `rbind()`

```{r}
Y <- matrix(0.1*(1:12),3,4)

cbind(X,Y)  # bind column-wise
rbind(X,Y)  # bind row-wise
```

-----------------------------------------------

## Factors

```{r}
gender<-c(rep("female",691),rep("male",692))
class(gender)

# change vector to factor (i.e. a category)
gender<- factor(gender)
levels(gender)

summary(gender)
table(gender)

status<- c(0,3,2,1,4,5)    # This command creates a numerical vector pain, 
                           #    encoding the pain level of five patients.
fstatus <- factor(status, levels=0:5)
levels(fstatus) <- c("student","engineer","unemployed","lawyer","economist","dentist")

Dat$status <- fstatus
Dat
````

-----------------------------------------------

##  Indexing vector with logicals

```{r}
a <- c(1,2,3,4,5)
b <- c(TRUE,FALSE,FALSE,TRUE,FALSE)

max(a[b])

sum(a[b])
````

## Missing values

In `R`, missing values are represented by the symbol `NA` (not available) . Impossible values (e.g., dividing by zero) are represented by the symbol `NaN` (not a number). 

```{r}
a <- c(1,2,3,4,NA)
sum(a)
```

Excluding missing values from functions

```{r}
sum(a,na.rm=TRUE)

a <- c(1,2,3,4,NA)
is.na(a)
```

The function `complete.cases()` returns a logical vector indicating which cases are complete.

```{r}
complete.cases(a)
```

The function `na.omit()` returns the object with listwise deletion of missing values. 

```{r}
na.omit(a) 
```

`NA` in data frames:

```{r, eval=FALSE}
require(graphics)
?airquality
pairs(airquality, panel = panel.smooth, main = "airquality data")
ok <- complete.cases(airquality)
airquality[ok,]
```


## Working with data frames

 * A data frame is used for storing data tables. It is a list of vectors of equal length. 
```{r,results="hide"}
mtcars
?mtcars       # or help(mtcars)
```

* look at the first rows

```{r}
head(mtcars)
```

* Structure of the data frame

```{r}
str(mtcars) # display the structure of the data frame
```

* Select a car model:
```{r, eval=FALSE}
mtcars["Mazda RX4",] # using rows and columns names
mtcars[c("Datsun 710", "Camaro Z28"),] 
```

* Or specific variables

```{r, eval=FALSE}
mtcars[,c("mpg","am")]
```

There are some packages that include particular functions to summarize data frames, for instance the library `psych` has the function `describe`

```{r, message=FALSE, warning=FALSE, eval=FALSE}
library(psych)
describe(mtcars)
```

------------------------------------



```{r,eval=FALSE,echo=FALSE,message=FALSE}
library(knitr)
purl("Ch1.Rmd",output="Ch1.R")
```


