---
title: 'Some examples of data analysis using **R**'
author: "Dae-Jin Lee"
date: "<dlee@bcamath.org>"
output:
  html_document:
    fig_caption: yes
    highlight: haddock
    keep_md: yes
    theme: cerulean
    toc: yes
    toc_depth: 1
subtitle: Azti course on introduction to `R` statistical software
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

------------------------------------------------

# The Forbes 2000 Ranking of the World's Biggest Companies (Year 2004)

The data handling and manipulation techniques explained will be illustrated by means of a data set of 2000 world leading companies, the Forbes 2000 list for the year 2004 collected by Forbes Magazine. This list is originally available from `www.forbes.com`

Here we show a subset of the data set:

```{r,echo=FALSE,message=FALSE,warning=FALSE}
library("HSAUR2")
data("Forbes2000")
library(knitr)
kable(head(Forbes2000))
```

The data consists of 2000 observations on the following 8 variables.
    
  * `rank`: the ranking of the company.
  * `name`: the name of the company.
  * `country`: a factor giving the country the company is situated in.
  * `category`: a factor describing the products the company produces.
  * `sales`: the amount of sales of the company in billion USD.
  * `profits`: the profit of the company in billion USD. 
  * `assets`: the assets of the company in billion USD.
  * `marketvalue`: the market value of the company in billion USD.
    
## Types of variables

`R` output

```{r,echo=FALSE}
str(Forbes2000)
```

## Factor levels

Nominal measurements are represented by factor variables in `R`, such as the country of the company or the category of the business segment.

A factor in `R` is divided into levels



How many countries are on the top 2000 ranking?

`R` output


```{r,echo=FALSE}
nlevels(Forbes2000[,"country"])
```

Which countries?

`R` output

```{r,echo=FALSE}
levels(Forbes2000[,"country"])
```

And in the top 20?

`R` output

```{r}
top20 <- droplevels(subset(Forbes2000,rank<=20))
levels(top20[,"country"])
```

As a simple summary statistic, the frequencies of the levels of such a factor variable can be found from

```{r}
table(top20[,"country"])
```


Which type of companies?

```{r}
levels(Forbes2000[,"category"])
```

How many of each category?

```{r}
table(Forbes2000[,"category"])
```

A simple summary statistics such as the mean, median, quantiles and range can be found from continuous variables such as `sales`

`R` output

```{r}
summary(Forbes2000[,"sales"])
```

## Simple Graphics

**Chambers et al. (1983)**, "there is no statistical tool that is as powerful as a well chosen graph"


Histograms and boxplots

```{r,fig.width=12,fig.height=10}
layout(matrix(1:4, nrow = 2,ncol=2))
hist(Forbes2000$marketvalue, col="lightgrey",main="Histogram of market value")
hist(log(Forbes2000$marketvalue),col="lightgrey",main="Histogram of log(market value)")
boxplot(Forbes2000$marketvalue, col="lightgrey",main="Boxplot of market value")
boxplot(log(Forbes2000$marketvalue),col="lightgrey",main="Boxplot of log(market value)")
```

Scatterplots to visualize the relationship betwen variables


```{r,fig.width=12,fig.height=10}
layout(matrix(1:2, nrow = 2))
plot(marketvalue ~ sales, data = Forbes2000, pch = ".")
plot(log(marketvalue) ~ log(sales), data = Forbes2000, pch = ".")
```

## Cool Graphics

Using the `ggplot2` library

```{r,message=FALSE,warning=FALSE}
library(ggplot2)
#?qplot
qplot(marketvalue,data = Forbes2000)
qplot(log(marketvalue),  data = Forbes2000)
qplot(marketvalue,sales, data=Forbes2000)
qplot(log(marketvalue),log(sales),size=assets,alpha = I(0.1),data=Forbes2000)
```


```{r,message=FALSE,warning=FALSE}
library(calibrate)
profits_all = na.omit(Forbes2000$profits)  # all_profts without No data
order_profits = order(profits_all)     # index of the profitable companies in decreasing order
top_50 = rev(order_profits)[1:50]      # top 50 profitable companies

sales = Forbes2000$sales[top_50]       # sales of the 50 top profitable companies
assets = Forbes2000$assets[top_50]     # assets of the 50 top profitable companies
countries = Forbes2000$country[top_50] # countries where the 50 top profitable companies are found

plot(assets,sales,pch =1)
textxy(assets,sales, abbreviate(countries,2),col = "blue",cex=0.5)  # used to put the countries where the companies are found
title(main = "Sales and Assets in billion USD \n of the 50 most profitable companies ", col.main = "gray")
```

## Graphics by factor

Boxplots of the logarithms of the market value for four selected countries, the width of the boxes is proportional to the square roots of the number of companies.

```{r, echo=FALSE}
tmp <- subset(Forbes2000,
        country %in% c("United Kingdom", "Germany",
                       "India", "Turkey"))
tmp$country <- tmp$country[,drop = TRUE]
plot(log(marketvalue) ~ country, data = tmp, col = 3:6,
       ylab = "log(marketvalue)", varwidth = TRUE)
```

Scatterplots by country

```{r. , warning=FALSE}
library(lattice)
xyplot(log(marketvalue)~log(sales)|country,data=tmp)
```

<!-- ## Questions -->


<!--   1. Calculate the median profit for the companies in the US and the median profit for the companies in the UK, France and Germany. -->
<!--   2. Find all German companies with negative profit. -->
<!--   3. To which business category do most of the Bermuda island companies belong? -->
<!--   4. For the 50 companies in the Forbes data set with the highest profits, plot sales against assets (or some suitable transformation of each variable), labelling each point with the appropriate country name which may need to be abbreviated (using abbreviate) to avoid making the plot look too "messy". -->
<!--   5. Find the average value of sales for the companies in each country in the Forbes data set, and find the number of companies in each country with profits above 5 billion US dollars. -->

 
-----------------------------------------


# Malignant Melanoma in the USA

Fisher and Belle (1993) report mortality rates due to malignant melanoma of the skin for white males during the period 1950-1969, for each state on the US mainland. 


```{r}
data("USmelanoma",package="HSAUR2")
library(knitr)
kable(USmelanoma)
```

A data consists of 48 observations on the following 5 variables.

  * `mortality`: number of white males died due to malignant melanoma 1950-1969 per one million inhabitants.

  * `latitude`: latitude of the geographic centre of the state.

  * `longitude`: longitude of the geographic centre of each state.

  * `ocean`: a binary variable indicating contiguity to an ocean at levels `no` or `yes`.


## Plotting mortality rates

```{r}
xr <- range(USmelanoma$mortality) * c(0.9, 1.1)
```

Let us plot mortality rates in 

```{r,fig.align='center'}
#layout(matrix(1:2, nrow = 2))
boxplot(USmelanoma$mortality, ylim = xr, horizontal = TRUE,xlab = "Mortality")
hist(USmelanoma$mortality, xlim = xr, xlab = "", main = "",axes = FALSE, ylab = "")
axis(1)
```

Malignant melanoma mortality rates by contiguity to an ocean

```{r,fig.align='center'}
plot(mortality ~ ocean, data = USmelanoma, xlab = "Contiguity to an ocean", ylab = "Mortality")
```

Histograms can often be misleading for displaying distributions because of their dependence on the number of classes chosen. An alternative is to formally estimate the density function of a variable and then plot the resulting estimate.

The estimated densities of malignant melanoma mortality rates by contiguity to an ocean looks like this:

```{r,fig.width=12,fig.height=10,fig.align='center'}
dyes <- with(USmelanoma, density(mortality[ocean == "yes"]))
dno <- with(USmelanoma, density(mortality[ocean == "no"]))
plot(dyes, lty = 1, xlim = xr, main = "", ylim = c(0, 0.018))
lines(dno, lty = 2)
legend("topright", lty = 1:2, legend = c("Coastal State","Land State"), bty = "n")
```


Now we might move on to look at how mortality rates are related to the geographic location of a state as represented by the latitude and longitude of the centre of the state. 

```{r,fig.align='center'}
layout(matrix(1:2, ncol = 2))
plot(mortality ~ -longitude, data = USmelanoma)
plot(mortality ~ latitude, data = USmelanoma)
```

## Mapping mortality rates

The data contains the longitude and latitude of the centroids 

```{r,fig.align='center',message=FALSE,warning=FALSE}
plot(-USmelanoma$longitude,USmelanoma$latitude,asp=1.5,cex=.3,pch=19,col="blue")
```


```{r,fig.align='center',message=FALSE,warning=FALSE}
library("sp")
library("maps")
library("maptools")
library("RColorBrewer")
map("state")
points(-USmelanoma$longitude,USmelanoma$latitude,asp=1.5,cex=.3,pch=19,col="blue")
```

```{r,fig.align='center',message=FALSE,warning=FALSE}
#qplot(-USmelanoma$longitude,USmelanoma$latitude,colour=USmelanoma$mortality,asp=1.5)+scale_color_gradient(low="blue", high="red")+geom_point()

#Create a function to generate a continuous color palette
rbPal <- colorRampPalette(c('blue','grey','red'))
#This adds a column of color values
# based on the y values
USmelanoma$Col <- (rbPal(10)[as.numeric(cut(USmelanoma$mortality,breaks = 10))])
map("state",xlim=c(-135,-65))
points(-USmelanoma$longitude,USmelanoma$latitude,col=USmelanoma$Col,asp=1.5,pch=19,cex=1.2)
legend("topleft",title="Decile",legend=quantile(USmelanoma$mortality,seq(0.1,1,l=10)),col =rbPal(10),pch=15,cex=1.,box.col = NA)
```

```{r,fig.width=12,fig.height=10,fig.align='center',message=FALSE,warning=FALSE}
states <- map("state", plot = FALSE, fill = TRUE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
rownames(USmelanoma) <- tolower(rownames(USmelanoma))

us1 <- map2SpatialPolygons(states, IDs=IDs,proj4string = CRS("+proj=longlat +datum=WGS84"))
us2 <- SpatialPolygonsDataFrame(us1, USmelanoma)

col <- colorRampPalette(c('blue', 'gray80','red'))

spplot(us2, "mortality", col.regions = col(200),par.settings = list(axis.line = list(col =  'transparent')),main="Map of the US showing malignant melanoma mortality rates")
```


# Drug Adverse Event Discovery

We can use some statistical techniques (unsupervised classification) to identify which drugs are associated with which adverse events. 

<!-- # Specifically, machine learning can help us to create clusters based on gender, age, outcome of adverse event, route drug was administered, purpose the drug was used for, body mass index, etc. This can help for quickly discovering hidden associations between drugs and adverse events. -->
<!-- #  -->
<!-- # Clustering is a non-supervised learning technique which has wide applications. Some examples where clustering is commonly applied are market segmentation, social network analytics, and astronomical data analysis. Clustering is grouping of data into sub-groups so that objects within a cluster have high similarity in comparison to other objects in that cluster, but are very dissimilar to objects in other classes. -->
<!-- #  -->
<!-- # Here, we will see how we can use hierarchical clustering to identify drug adverse events. -->

```{r,echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(caret)
library(dendextend)
library(stringi)
```


<!-- In the table shown below, the data base looks like: -->

<!-- ``` -->
<!--     Route=ORAL, Age=60s, Sex=M, Outc_code=OT, Indi_pt=RHEUMATOID ARTHRITIS and Pt=VASCULITIC RASH + some noise -->
<!--     Route=TOPICAL, Age=early 20s, Sex=F, Outc_code=HO, Indi_pt=URINARY TRACT INFECTION and Pt=VOMITING + some noise -->
<!--     Route=INTRAVENOUS, Age=about 5, Sex=F, Outc_code=LT, Indi_pt=TONSILLITIS and Pt=VOMITING + some noise -->
<!--     Route=OPHTHALMIC, Age=early 50s, Sex=F, Outc_code=DE, Indi_pt=Senile osteoporosis and Pt=Sepsis + some noise -->
<!-- ``` -->

The data loooks like this (this is a simulated database):

```{r}
Drugs <- read.table("data/Drugs.txt",sep="\t",header=TRUE)
kable(Drugs)
```

```{r,echo=FALSE, warning=FALSE}
age=Drugs$Age
df=select(Drugs,-Age)
my_matrix = as.data.frame(do.call(cbind, lapply(df, function(x) table(1:nrow(df), x))))
my_matrix$Age=age
#head(my_matrix)

preproc = preProcess(my_matrix)
my_matrixNorm = as.matrix(predict(preproc, my_matrix))

distances = dist(my_matrixNorm, method = "euclidean")

clusterdrug = hclust(distances, method = "ward.D") 

# plot(clusterdrug, cex=0.5, labels = FALSE,cex=0.5,xlab = "", sub = "",cex=1.2)

dend <- as.dendrogram(clusterdrug) 

# Color the branches based on the clusters:
dend <- color_branches(dend, k=4) #, groupLabels=iris_species)

# We hang the dendrogram a bit:
dend <- hang.dendrogram(dend,hang_height=0.1)
# reduce the size of the labels:
# dend <- assign_values_to_leaves_nodePar(dend, 0.5, "lab.cex")
dend <- set(dend, "labels_cex", 0.5)

plot(dend)

clusterGroups = cutree(clusterdrug, k = 4)

df$cluster=clusterGroups

#head(kable(df))


##### 
observationsH=c()

for (i in seq(1,4)){
  observationsH=c(observationsH,length(subset(clusterdrug, clusterGroups==i)))
}
observationsH =as.data.frame(list(cluster=c(1:4),Number_of_observations=observationsH))

kable(observationsH)

# other clustering techniques
distances = dist(my_matrixNorm, method = "canberra")

clusterdrug = hclust(distances, method = "mcquitty") 

#plot(clusterdrug, cex=0.5, labels = FALSE,cex=0.5,xlab = "", sub = "",cex=1.2)

dend <- as.dendrogram(clusterdrug) 

# Color the branches based on the clusters:
dend <- color_branches(dend, k=4) #, groupLabels=iris_species)

# We hang the dendrogram a bit:
dend <- hang.dendrogram(dend,hang_height=0.1)
# reduce the size of the labels:
# dend <- assign_values_to_leaves_nodePar(dend, 0.5, "lab.cex")
dend <- set(dend, "labels_cex", 0.5)

plot(dend)

clusterGroups2 = cutree(clusterdrug, k = 4)
df$cluster2=clusterGroups2
#df


# What is the most common observation in each cluster? Calculate column average for each cluster

z=do.call(cbind,lapply(1:4, function(i) round(colMeans(subset(my_matrix,clusterGroups==i)),2)))
colnames(z)=paste0('cluster',seq(1,4))
# z


Age=z[nrow(z),]
z=z[1:(nrow(z)-1),]

my_result=matrix(0,ncol=4,nrow=ncol(df))
for(i in seq(1,4)){
    for(j in seq(1,ncol(df))){
q = names(df)[j]
q = as.vector(as.matrix(unique(df[q])))
my_result[j,i]=names(sort(z[q,i],decreasing = TRUE)[1])
    }}

colnames(my_result)=paste0('Cluster',seq(1,4))
rownames(my_result)=names(df)
my_result=rbind(Age,my_result)
my_result <- cbind(Attribute =c("Age","Route","Sex","Outcome Code","Indication preferred term","Adverse event"), my_result)
rownames(my_result) <- NULL

my_result<-my_result[1:6,]


#my_result

kable(as.data.frame(my_result))

```



