---
title: '**Introduction to `R` statistical software**'
author: "Dae-Jin Lee < dlee@bcamath.org >"
date: "Azti - Tecnalia"
output:
  html_document:
    fig_caption: yes
    highlight: haddock
    keep_md: yes
    number_sections: yes
    theme: cerulean
    toc: yes
    toc_depth: 2
  pdf_document:
    fig_caption: yes
    fig_height: 4
    fig_width: 5
    highlight: tango
    includes:
      in_header: mystyle.sty
    keep_tex: yes
    number_sections: yes
    template: introSM_template.tex
    toc: yes
    toc_depth: 2
  word_document: default
header-includes:
- \usepackage{hyperref}
- \usepackage{palatino}
- \usepackage{mathtools}
subtitle: BCAM - Basque Center for Applied Mathematics, Applied Statistics
bibliography: MMrefs.bib
---


***********


This course is an introduction to statistical software `R`. The course will introduce the student to the basics of using `R` for statistical programming, computation, graphics, and basic statistical modeling. 

<!-- This course is oriented to undergraduate and Master students, or any researcher interested in learning the statistical software `R`. -->


**Objectives:**

- Use `R` for basic data analysis. 
- Write functions in and use `R` in efficient way,
- Perform basic statistical analysis and basic statistical models.

**Pre-requisites:**

There are no formal prerequisites, but some basic knowledge of statistics is expected. The intended audience is anyone who needs a flexible statistical environment for their research. Any prior knowledge of `R` is not expected.

**Compulsory:**

- Bring your laptop with the latest version of `R` installed. Download it [here](https://cran.r-project.org/)
- Rstudio is a user-friendly interface. Download it [here](https://www.rstudio.com/products/rstudio/download/) **Highly recommended!!!**
- Internet connection to download the material and install some packages.

*************************************************


  
# Introduction to the `R` language

* `R` is a free software environment for statistical computing and graphics <http://www.r-project.org>

* `R` is a command-driven statistical package.

* The most important reasons to use `R` are:

    + `R` is free and multiplatform (Windows/Linux/MACos)

    + `R` allows you to do all the statistical tests/models/analysis you need :)

    + Excellent graphics and programming capabilities

    + Growing community of users and developers 

    + Lots of online resources

* Statistical features:

    + Graphical Techniques (Exploratory Data Analysis)
    
    + Linear and non-linear modeling (linear regression, non-parametric regression, smoothing, etc ...)
    
    + Classical statistical tests
    
    + Time-series analysis
    
    + Econometrics
    
    + Survival analysis
    
    + Classification and clustering (data mining, machine learning)
    
    + Optimization and Mathematical Programming
    
    + Bayesian inference etc ....

**Visit** http://cran.r-project.org/web/views
 or http://stackoverflow.com/questions/tagged/r
 
 
 
## Start with `R`

* Get current working directory 

```{r,eval=FALSE}
getwd() 
```

* list the objects in the current workspace

```{r,eval=FALSE}
ls()
```

* Set working directory

```{r, eval=FALSE}
setwd("/Users/dlee") 
```

* work with your previous commands

```{r,eval=FALSE}
history() # display last 25 commands
history(max.show=Inf) # display all previous commands
```


* save your command history

```{r,eval=FALSE}
savehistory(file="myfile") # default is ".Rhistory"
```

* recall your command history

```{r,eval=FALSE}
loadhistory(file="myfile") # default is ".Rhistory"
```


* save the workspace to the file `.RData` 

```{r, eval=FALSE}
save.image()
```

* save specific objects to a file  if you don't specify the path, the cwd is assumed

```{r,eval=FALSE}
save(<object list>,file="myfile.RData") 
```


* load a workspace into the current session

```{r,eval=FALSE}
load("myfile.RData") 
```


* quit `R`. You will be prompted to save the workspace. 

```{r,eval=FALSE}
q()
```


## Install and load an `R` library
 
```{r,eval=FALSE}
install.packages("DAAG") # (Data Analysis And Graphics)
```

* Once installed the package, load it
```{r,warning=FALSE,message=FALSE}
library(DAAG) # or require(DAAG)
```
 
-------------------------------------

## Reading data

The `R` console


```{r}
x <- c(7.82,8.00,7.95) # c means "combine"
x
```

A quicker way is to use `scan()`

```{r,eval=FALSE}
x <- scan()  # enter a number followed by return and blank line to end
1: 7.82
2: 8.00
3: 7.95
4: 
Read 3 items
```
To create a character vector use `""`

```{r}
id <- c("John","Paul","George","Ringo")
```


To read a character vector 
```{r,eval=FALSE}
id <- scan(,"")
1: John
2: Paul
3: George
4: Ringo
5: 
Read 4 items  
```

```{r}
id
```


## Data Import

In most situations, we need to read data from a separate data file. There are several methods for doing this. 

* `scan()` (see `?scan` for help)


```{r}
cat("Example:", "2 3 5 7", "11 13 17", file = "ex.txt", sep = "\n") # creates ex.txt
scan("ex.txt", skip = 1)
scan("ex.txt", skip = 1, nlines = 1) # only 1 line after the skipped one
unlink("ex.data") # tidy up
```

* Several formats are available (`.txt`, `.csv`, `.xls`, `.xlsx`, `SAS`, `Stata`, etc...)

* Some `R` libraries to import data are 

```{r,message=FALSE,warning=FALSE}
library(gdata)
library(foreign)
``` 

\bigskip

* Read data from a `.txt` or `.csv` files

```{r,eval=FALSE}
mydata1 = read.table("mydata.txt") 
mydata2 = read.csv("mydata.csv")  
```

* Other formats `.xls` and `.xlsx`

```{r,eval=FALSE,message=FALSE,warning=FALSE}
# read in the worksheet named mysheet
mydata <- read.xlsx("myexcel.xlsx", sheetName = "mysheet")
```

---------------------------------


* Minitab, SPSS, SAS or Stata

```{r, eval=FALSE, message=FALSE}
library(foreign)                   
mydata = read.mtp("mydata.mtp")  # Minitab
mydata = read.spss("myfile", to.data.frame=TRUE) # SPSS
mydata = read.dta("mydata.dta") # Stata
```

* Or
```{r,eval=FALSE}
library(Hmisc)
mydata = spss.get("mydata.por", use.value.labels=TRUE)  # SPSS
```

-------------------------

## Exporting data

* There are numerous methods for exporting `R` objects into other formats . For SPSS, SAS and Stata. you will need to load the `foreign` packages. For Excel, you will need the `xlsx` package.  
 
 - Tab delimited text file

```{r,eval=FALSE}
mtcars
?mtcars    
write.table(mtcars, "mydata.txt", sep="\t") 
```

*  Excel spreadsheet

```{r,eval=FALSE}
library(xlsx)
write.xlsx(mydata, "mydata.xlsx")
```


----------------------------

## Data vectors

* Download `R code` [here](http://idaejin.github.io/bcam-courses/rbasics/rbasics.R)

* Create a vector of weights and heights

```{r}
weight<-c(60,72,57,90,95,72)  
class(weight)
height<-c(1.75,1.80,1.65,1.90,1.74,1.91)
```

* calculate Body Mass Index
```{r} 
bmi<- weight/height^2
bmi
```

----------------------------


## Basic statistics 

* mean, median, st dev, variance

```{r,eval=FALSE}
mean(weight) 
median(weight)
sd(weight)
var(weight)
```

* summarize data

```{r}
summary(weight)
```

* or

```{r,eval=FALSE}
min(weight)
max(weight)
range(weight)
sum(weight)
length(weight)
```

* Quantiles and percentile

There are several quartiles of an observation variable. The first quartile, or lower quartile, is the value that cuts off the first 25% of the data when it is sorted in ascending order. The second quartile, or median, is the value that cuts off the first 50%. The third quartile, or upper quartile, is the value that cuts off the first 75%. 

```{r}
quantile(weight)
```

The $n^{\rm th}$ percentile of an observation variable is the value that cuts off the first $n$ percent of the data values when it is sorted in ascending order. 

```{r}
quantile(weight,c(0.32,0.57,0.98))
```

* Covariance and correlation 


The *covariance* of two variables $x$ and $y$ in a data sample measures how the two are linearly related. A positive covariance would indicates a positive linear relationship between the variables, and a negative covariance would indicate the opposite.


$$
\rm{Cov}(x,y) = \frac{1}{n}\sum_{i=1}^{n}(x_i - \bar{x})(y_i - \bar{y})
$$

```{r}
cov(weight,height)
```

The *correlation coefficient* of two variables in a data sample is their covariance divided by the product of their individual standard deviations. It is a normalized measurement of how the two are linearly related.

Formally, the sample correlation coefficient is defined by the following formula, where $\sigma_x$ and $\sigma_y$ are the sample standard deviations, and $\sigma_xy$ is the covariance. 

$$
      \rho_{xy}  = \frac{\sigma_{xy}}{\sigma_x~\sigma_y}
$$

```{r}
cor(weight,height)
```
----------------------------------

## Character vectors and factor variables

```{r}
subject <- c("John","Peter","Chris","Tony","Mary","Jane")
sex <- c("MALE","MALE","MALE","MALE","FEMALE","FEMALE")
class(subject)
table(sex)
```


-----------------------------------


## Data frames
```{r}
Dat <- data.frame(subject,sex,weight,height)
# add bmi to Dat
Dat$bmi <- bmi  # or Dat$bmi <- weight/height^2
class(Dat)
str(Dat) # display object structure
```


```{r}
# Change rownames
rownames(Dat)<-c("A","B","C","D","E","F")

# Access to data frame elements (similar to a matrix)
Dat[,1]     # 1st column
Dat[,1:3]   # 1st to 3rd columns
Dat[1:2,]   # 1st to 2nd row
```



## Working with data frames

**Example: Analyze data by groups**

*  Obtain the mean weight, heigth and bmi means by FEMALES and MALES:

1. Select each group and compute the mean

```{r, results='hide'}
Dat[sex=="MALE",]
Dat[sex=="FEMALE",]

mean(Dat[sex=="MALE",3])  # weight average of MALEs
mean(Dat[sex=="MALE","weight"])
```

2. Use `apply` by columns 
```{r, results='hide'}
apply(Dat[sex=="FEMALE",3:5],2,mean)
apply(Dat[sex=="MALE",3:5],2,mean)

# we can use apply with our own function
apply(Dat[sex=="FEMALE",3:5],2,function(x){x+2})
```

3. `by` and `colMeans`

```{r, results='hide'}
# 'by' splits your data by factors and do calculations on each subset.
by(Dat[,3:5],sex, colMeans) 
```

4. `aggregate`

```{r, results='hide'}
# another option
aggregate(Dat[,3:5], by=list(sex),mean) 
```

------------------------------------

## Logical vectors

* Choose individuals with BMI>22
```{r,results='hide'}
bmi
bmi>22
as.numeric(bmi>22) # convert a logical condition to a numeric value 0/1
which(bmi>22)  # gives the position of bmi for which bmi>22
```

* Which are between 20 and 25?

```{r,results='hide'}
bmi > 20 & bmi < 25
which(bmi > 20 & bmi < 25)
```

--------------------------------------

## Working with vectors 

* Concatenate

```{r,results='hide'}
x <- c(2, 3, 5, 2, 7, 1)
y <- c(10, 15, 12)
z <- c(x,y)  # concatenates x and y
```

* list two vectors

```{r}
zz <- list(x,y) # create a list
unlist(zz) # unlist the list converting it to a concatenated vector
``` 

* subset of vectors

```{r}
x[c(1,3,4)]

x[-c(2,6)] # negative subscripts omit the chosen elements 
```

* Sequences
```{r}
seq(1,9) # or 1:9
seq(1,9,by=1)
seq(1,9,by=0.5)
seq(1,9,length=20)
```

* Replicates

```{r,results='hide'}
oops <- c(7,9,13)
rep(oops,3) # repeats the entire vector "oops" three times
rep(oops,1:3) # this function has the number 3 replaced 
              #  by a vector with the three values (1,2,3) 
              #  indicating that 7 should be repeated once, 9 twice and 13 three times.

rep(c(2,3,5), 4)
rep(1:2,c(10,15))

rep(c("MALE","FEMALE"),c(4,2)) # it also works with character vectors 
c(rep("MALE",3), rep("FEMALE",2))
```

---------------------------------------------


## Matrices and arrays

```{r}
x<- 1:12
x
dim(x)<-c(3,4)  # 3 rows and 4 columns

X <- matrix(1:12,nrow=3,byrow=TRUE)
X

X <- matrix(1:12,nrow=3,byrow=FALSE)
X

# rownames, colnames

rownames(X) <- c("A","B","C")
X
colnames(X) <- LETTERS[4:7]
X
colnames(X) <- month.abb[4:7]
X
```

* Column/Row bind operations `cbind()`, `rbind()`

```{r}
Y <- matrix(0.1*(1:12),3,4)

cbind(X,Y)  # bind column-wise
rbind(X,Y)  # bind row-wise
```

-----------------------------------------------

## Factors

```{r}
gender<-c(rep("female",691),rep("male",692))
class(gender)

# change vector to factor (i.e. a category)
gender<- factor(gender)
levels(gender)

summary(gender)
table(gender)

status<- c(0,3,2,1,4,5)    # This command creates a numerical vector pain, 
                           #    encoding the pain level of five patients.
fstatus <- factor(status, levels=0:5)
levels(fstatus) <- c("student","engineer","unemployed","lawyer","economist","dentist")

Dat$status <- fstatus
Dat
````

-----------------------------------------------

##  Indexing vector with logicals

```{r}
a <- c(1,2,3,4,5)
b <- c(TRUE,FALSE,FALSE,TRUE,FALSE)

max(a[b])

sum(a[b])
````

## Missing values (NA)

```{r}
a <- c(1,2,3,4,NA)
sum(a)
sum(a,na.rm=TRUE)

a <- c(1,2,3,4,NA)
is.na(a)
```



------------------------------------------------

## Working with data frames

 * A data frame is used for storing data tables. It is a list of vectors of equal length. 
```{r,results="hide"}
mtcars
?mtcars       # or help(mtcars)
```

* look at the first rows

```{r}
head(mtcars)
```

* Structure of the data frame

```{r}
str(mtcars) # display the structure of the data frame
```

* Select a car model:
```{r}
mtcars["Mazda RX4",] # using rows and columns names
mtcars[c("Datsun 710", "Camaro Z28"),] 
```

* Or specific variables

```{r}
mtcars[,c("mpg","am")]
```

```{r, message=FALSE, warning=FALSE}
library(psych)
describe(mtcars)
```

------------------------------------

# Basic data analysis in `R`

## Basic plotting


*  Scatterplot

```{r}
attach(mtcars)
plot(wt, mpg, main="Scatterplot Example",
   xlab="Car Weight ", ylab="Miles Per Gallon ", pch=19) 
```

* Basic Scatterplot Matrix

```{r}
pairs(~mpg+disp+drat+wt,data=mtcars,
   main="Simple Scatterplot Matrix")
```

* Barplot

```{r,fig.pos='center'}
tab <- table(mtcars[,c("cyl")])
barplot(tab)
```

* Piechart

```{r,fig.align='center'}
pie(tab)
```



-----------------------------------------

**Exercises:**

1. The data.frame `VADeaths` contains the death rates per 1000 in Virginia (US) in 1940

  + The death rates are measured per 1000 population per year. They are cross-classified by age group (rows) and population group (columns). The age groups are: 50-54, 55-59, 60-64, 65-69, 70-74 and the population groups are Rural/Male, Rural/Female, Urban/Male and Urban/Female.

```{r}
data(VADeaths)
VADeaths
```

* Compute the mean for each age group. 

      + **Result:**

```{r,echo=FALSE}
apply(VADeaths,1,mean)
```

* Compute the mean for each population group. 

      + **Result:** 
      
```{r,echo=FALSE}
apply(VADeaths,2,mean)
```

2. The  `data.frame` `rainforest` contains several variables from different `species`

```{r, results='hide'}
library(DAAG)
rainforest
```

  * Create a table of counts for each `species` and make a graphic with the results. 
  
      + **Result:**
      
```{r,echo=FALSE}
table(rainforest$species)
barplot(table(rainforest$species))
```

3. The `Acmena` `data.frame` is created from  `rainforest` using the function `subset`. 

  * Plot the relationship between the wood biomass (`wood`) and the diameter of the breast height (`dbh`). Use also a logarithm scale.

```{r}
Acmena <- subset(rainforest, species == "Acmena smithii")
```

 
```{r,echo=FALSE, fig.width=10,fig.height=8}
par(mfrow=c(1,2))
plot(wood~dbh,data=Acmena,pch=19, main="plot of dbh vs wood")
plot(log(wood)~log(dbh),data=Acmena,pch=19,main="log transformation")
```


  * Compute a histogram of variable `dbh` using function `hist`

```{r,echo=FALSE}
hist(Acmena$dbh)
```

4. Create a vector of the positive odd integers less than 100 and remove the values greater than 60 and less than 80.

    * **Result:** 
    
```{r,echo=FALSE}
  x <- seq(1,100,by=2)
  x[x>60 & x<80]
```


* [Solutions here](http://idaejin.github.io/bcam-courses/rbasics/rbasics_sol.R)


***********

## Scatterplots

```{r, message= FALSE, warning=FALSE}
library(MASS)
data("mammals")
?mammals
head(mammals)
attach(mammals)
species <- row.names(mammals)
x <- body
y <- brain
```

```{r,fig.align='center'}
library(calibrate)
# scatterplot
plot(x,y, xlab = "body weight in kgr", ylab = "brain weight in gr", 
     main="Body vs Brain weight \n for 62 Species of Land Mammals")
textxy(x,y,labs=species,col = "blue",cex=0.85) 
```

Identify a point in the scatterplot
```{r, eval=FALSE}
identify(x,y,species)
```

Plot in the log scale
```{r,fig.align='center'}
plot(log(x),log(y), xlab = "log body weight in kgr", ylab = "log brain weight in gr", 
     main="log Body vs log Brain weight \n for 62 Species of Land Mammals")
textxy(log(x),log(y),labs=species,col = "blue",cex=0.85) 
```

Identify a point in the log scale scatterplot
```{r, eval=FALSE}
identify(log(x),log(y),species)
```

## More plotting options

**Multiple Data Sets on One Plot**

One common task is to plot multiple data sets on the same plot. In many situations the way to do this is to create the initial plot and then add additional information to the plot. For example, to plot bivariate data the `plot` command is used to initialize and create the plot. The `points` command can then be used to add additional data sets to the plot.


```{r}
 x <- rnorm(10,sd=5,mean=20)
 y <- 2.5*x - 1.0 + rnorm(10,sd=9,mean=0)
 cor(x,y)
 plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot")
 x1 <- runif(8,15,25)
 y1 <- 2.5*x1 - 1.0 + runif(8,-6,6)
 points(x1,y1,col=2)
```

with legend and $(x_2,y_2)$ points:
```{r}
x2 <- runif(8,15,25)
y2 <- 2.5*x2 - 1.0 + runif(8,-6,6)
 plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot")
 points(x1,y1,col=2,pch=3)
 points(x2,y2,col=4,pch=5)
 legend("topleft",c("Original","one","two"),col=c(1,2,4),pch=c(1,3,5))
```

**Errors bars:**

```{r,fig.width=8,fig.height=6}
plot(x,y,xlab="Independent",ylab="Dependent",main="Random plot",ylim=c(20,90))
xHigh <- x
yHigh <- y + abs(rnorm(10,sd=3.5))
xLow <- x
yLow <- y - abs(rnorm(10,sd=3.1))
arrows(xHigh,yHigh,xLow,yLow,col=2,angle=90,length=0.1,code=3)
```

```{r,fig.width=8,fig.height=6}
plot(1:20,0*(1:20),pch=1:20,cex=2)
```

**Multiple Graphs on One Image:**

```{r}
 par(mfrow=c(2,3))
 boxplot(rnorm(100),main="first plot")
 boxplot(rgamma(100,2),main="second plot", horizontal=TRUE,col="bisque")
 plot(rnorm(100),xlab="third plot",
      ylab="y-label",main="x-label")
 hist(rnorm(100),main="fourth plot",col="lightgrey")
 hist(rexp(100),main="fifth plot",col="blue")
 plot(rnorm(100),rexp(100),main="sixth plot")
```

**Pairwise relationships**

```{r}
uData <- rnorm(20)
vData <- rnorm(20,mean=5)
wData <- uData + 2*vData + rnorm(20,sd=0.5)
xData <- -2*uData+rnorm(20,sd=0.1)
yData <- 3*vData+rnorm(20,sd=2.5)
d <- data.frame(u=uData,v=vData,w=wData,x=xData,y=yData)
pairs(d)
```

**Plotting correlations**

The function `corrplot` in the `library(corrplot)` visualizes a correlation matrix calculate with function `cor`

```{r, fig.width=8}
library(corrplot)
M <- cor(d)
corrplot(M, method="circle",type="upper")
```

**Plotting surfaces: `image`, `contour` and `persp` plots**

```{r, fig.width=10, fig.height=10}
x <- seq(0,2*pi,by=pi/50)
y <- x
xg <- (x*0+1) %*% t(y)
yg <- (x) %*% t(y*0+1)
f <- sin(xg*yg)

par(mfrow=c(2,2))
image(x,y,f)
contour(x,y,f)
contour(x,y,f,nlevels=4)
image(x,y,f,col=grey.colors(100))
contour(x,y,f,nlevels=4,add=TRUE,col="red")
```

Similarly, one can use `persp` plot
```{r}
persp(x,y,f,theta=-30,phi=55,col="lightgrey",shade=.01)
```

## QQ-plot 

A Q-Q plot is a plot of the quantiles of two distributions against each other, or a plot based on estimates of the quantiles. The pattern of points in the plot is used to compare the two distributions.


`qqnorm` is used to determine if your data is close to being normally distributed. You cannot be sure that the data is normally distributed, but you can rule out if it is not normally distributed. 


```{r}
set.seed(1234)

require(graphics)
y <- rt(200, df = 5)
qqnorm(y); 
qqline(y, col = 2)

z <- rnorm(200,mean=0,sd=1)
qqnorm(z)
qqline(z, col = 2)
```

To compare two distributions
```{r}
set.seed(1234)
qqplot(qchisq(ppoints(500), df = 3), y,
       main = expression("Q-Q plot for" ~~ {chi^2}[nu == 3]))
qqline(y, distribution = function(p) qchisq(p, df = 3),
       prob = c(0.1, 0.6), col = 2)
```
If the two distributions being compared are identical, the Q-Q plot follows the $45º$ line y = x.


## Tables and Cross-classification

```{r}
library(MASS)
data(quine)
?quine
attach(quine)
table(Sex)
table(Sex,Age)

# or xtabs
xtabs(~Sex+Age,data=quine)
xtabs(~Sex+Age+Eth,data=quine)
```

## Calculation of cross-classifications

```{r}
tapply(Days,Age,mean)
```

```{r}
tapply(Days,list(Sex,Age),mean)
```


```{r}
tapply(Days,list(Sex,Age),function(x) sqrt(var(x)/length(x)))
```


## Qualitative data


A data sample is called qualitative, also known as categorical, if its values belong to a collection of known defined non-overlapping classes. Common examples include student letter grade (A, B, C, D or F), commercial bond rating (AAA, AAB, ...) and consumer clothing shoe sizes (1, 2, 3, ...).


Let us consider some artificial data consisting of the `treatment` and `improvement` of patients with rheumatoid arthritis.

```{r}
treatment <- factor(rep(c(1, 2), c(43, 41)), levels = c(1, 2),
                    labels = c("placebo", "treated"))
improved <- factor(rep(c(1, 2, 3, 1, 2, 3), c(29, 7, 7, 13, 7, 21)),
                   levels = c(1, 2, 3),
                   labels = c("none", "some", "marked"))
```
We can compute a cross-classification table
```{r}
xtabs(~treatment+improved)
```

Graphically,
```{r}
spineplot(improved ~ treatment)
```


The `R` dataset `UCBAdmissions` contains aggregated data on applicants to graduate school at Berkeley for the six largest departments in 1973 classified by admission and sex.


```{r}
data("UCBAdmissions")
?UCBAdmissions
apply(UCBAdmissions, c(2,1), sum)
prop.table(apply(UCBAdmissions, c(2,1), sum))
ftable(UCBAdmissions)
```

The same but with a more readable format can be obtained using `ftable`
```{r}
ftable(round(prop.table(UCBAdmissions), 3),
       row.vars="Dept", col.vars = c("Gender", "Admit"))
```

More interesting are the proportions admitted for each `Gender` by `Dept` combination (dimensions 2 and 3 of the array).  Notice that `male` and `female` admission rates are about the same in all departments, except "A", where female admission rates are higher.

```{r}
# prop.table(UCBAdmissions, c(2,3))
ftable(round(prop.table(UCBAdmissions, c(2,3)), 2),
       row.vars="Dept", col.vars = c("Gender", "Admit"))
```


```{r}
## Data aggregated over departments
apply(UCBAdmissions, c(1, 2), sum)
````


Applications and admissions by department at UC Berkeley can be viewed graphically

```{r}
spineplot(margin.table(UCBAdmissions, c(3, 2)),
           main = "Applications at UCB")
spineplot(margin.table(UCBAdmissions, c(3, 1)),
           main = "Admissions at UCB")

```


This data set is frequently used for illustrating *Simpson's paradox*. At issue is whether the data show evidence of sex bias in admission practices. There were 2691 male applicants, of whom 1198 (44.5%) were admitted, compared with 1835 female applicants of whom 557 (30.4%) were admitted. Men were much more successful in admissions than women. [Wikipedia: Gender Bias UC Berkeley](https://en.wikipedia.org/wiki/Simpson%27s_paradox#UC_Berkeley_gender_bias). 
 


## Quantitative data

Quantitative data, also known as continuous data, consists of numeric data that support arithmetic operations. This is in contrast with qualitative data, whose values belong to pre-defined classes with no arithmetic operation allowed. We will explain how to apply some of the R tools for quantitative data analysis with examples.

```{r}
head(faithful)
```

It consists of a collection of observations of the Old Faithful geyser in the USA Yellowstone National Park. 


There are two observation variables in the data set. The first one, called `eruptions`, is the duration of the geyser eruptions. The second one, called `waiting`, is the length of waiting period until the next eruption. It turns out there is a correlation between the two variables.

```{r}
plot(faithful)
```

### Frequency distribution of quantitative data

The frequency distribution of a data variable is a summary of the data occurrence in a collection of non-overlapping categories. 

Let us find the frequency distribution of the eruption duration in `faithful` data set.

```{r}
duration <- faithful$eruptions
range(duration)
```

Now we create the range of non-overlapping sub-intervals by defining a sequence of equal distance break points. If we round the endpoints of the interval [1.6, 5.1] to the closest half-integers, we come up with the interval [1.5, 5.5]. Hence we set the break points to be the half-integer sequence { 1.5, 2.0, 2.5, ... }. 

```{r}
breaks <- seq(1.5,5.5,by=0.5)
breaks
```

Classify the eruption durations according to the half-unit-length sub-intervals with cut. As the intervals are to be closed on the left, and open on the right, we set the right argument as `FALSE`. 

```{r}
duration.cut = cut(duration, breaks, right=FALSE) 
```
Compute the frequency of eruptions in each sub-interval with the table function. 

```{r}
duration.freq = table(duration.cut) 
duration.freq
```

`hist` function does all the computaions to find the frequency distribution:

```{r}
freq <- hist(duration)
freq

freq <- hist(duration,breaks = breaks)

hist(duration,50)
```


**Density estimation** builds an estimate of some underlying probability density function
using an observed data sample.

```{r}
require(graphics)
d <- density(faithful$eruptions)
d
plot(d)
```

Two dimension histogram:

```{r,message=FALSE,warning=FALSE}
library(gplots)
h2 <- hist2d(faithful, nbins=30,xlab="Duration in minutes",ylab="Waiting")
h2
names(h2)
```

Relative frequencies 

```{r}
duration.relfreq <- duration.freq / nrow(faithful) 
tab <- cbind(duration.freq, duration.relfreq) 
apply(tab,2,sum)
```

Cumulative frequency distribution

```{r}
cumsum(duration.freq)
cumsum(duration.relfreq)
```

We can plot the cumulative relative frequency graph of a quantitative variable, which is a curve graphically showing the cumulative relative frequency distribution. 
The e.c.d.f. (empirical cumulative distribution function) $F_n$ is a step function with jumps $i/n$ at observation values, where $i$ is the number of tied observations at that value. Missing values are ignored.

For observations $x = (x_1,x_2, ... x_n)$, $F_n$ is the fraction of observations less or equal to $t$, i.e.,

$$
F_n(t) = \#{x_i <= t}/n = 1/n \sum_{i=1}^n I(x_i \leq t).
$$
where $I$ is an indication function.




```{r}
plot(ecdf(duration))
```

**Bivariante Density estimation:**
```{r}
data("faithful")
attach(faithful)
Dens2d<-kde2d(eruptions,waiting)
image(Dens2d,xlab="eruptions",ylab="waiting")
contour(Dens2d,add=TRUE,col="black",lwd=2,nlevels=5)
detach("faithful")
```

**Perspective plot:**

```{r}
persp(Dens2d,phi=30,theta=20,d=5,xlab="eruptions",ylab="waiting",zlab="",shade=.2,col="lightblue",expand=.85,ticktype = "detailed")
```


# Introduction to basic programming in `R`


## Control Structures

### Conditional Executions

#### Comparison Operators

  - equal: `==`
  
```{r}
  "hola" == "hola"
  "hola" == "Hola"
   1 == 2-1
```

  
  
  - not equal: `!=`
  

```{r}
    a <- c(1,2,4,5)
    b <- c(1,2,3,5) 
    a == b
    a != b
```
  
  - greater/less than: `>` `<`

```{r}
set.seed(1)
a <- rnorm(10,3,1)
b <- rnorm(10,4,2)
a<b
```  

  - greater/less than or equal: `>=` `<=`
  
```{r}
set.seed(1)
a <- rpois(10,1)
b <- rbinom(10,2,.56)
a >= b
```


  - `which`
```{r}
set.seed(1)
which(a>b)

LETTERS
which(LETTERS=="R")
```
 
  - `which.min` or `which.max`
```{r}
set.seed(1)
a <- rnorm(10,2,1)
a
which.min(a)
which.max(a)
```

  - `is.na`
```{r}
 a[2] <- NA
is.na(a)
which(is.na(a))
```

### Logical Operators

  - and: `&`

```{r}
z = 1:6
which(2 < z & z > 3)
```

  - or: `|`
  
```{r}
z = 1:6
(z > 2) & (z < 5)
which((z > 2) & (z < 5))
```

  - not: `!`

```{r}
x <- c(TRUE,FALSE,0,6)
y <- c(FALSE,TRUE,FALSE,TRUE)

!x
```

Operators `&` and `|` perform element-wise operation producing result having length of the longer operand. But `&&` and `||` examines only the first element of the operands resulting into a single length logical vector. Zero is considered `FALSE` and non-zero numbers are taken as `TRUE`. **Example:**


  - `&&` vs `&`

```{r}
x&y
x&&y
```

 - `||` vs `|`
 
 
```{r}
x||y
x|y
```


## `if` statements

`if(cond1=true) { cmd1 } else { cmd2 }`

```{r}
if(1==0) {
    print(1)
} else {
    print(2)
}
```

## `ifelse` statement

`ifelse(test, true_value, false_value)`

```{r}
x <- 1:10 # Creates sample data
ifelse(x<5 | x>8, x, 0)
```


## `while` statement


## Loops

The most commonly used loop structures in `R` are `for`, `while` and `apply` loops. Less common are `repeat` loops. The `break` function is used to break out of loops, and next halts the processing of the current iteration and advances the looping index.

### `for`

For loops are controlled by a looping vector. In every iteration of the loop one value in the looping vector is assigned to a variable that can be used in the statements of the body of the loop. Usually, the number of loop iterations is defined by the number of values stored in the looping vector and they are processed in the same order as they are stored in the looping vector.


Syntax
```
for(variable in sequence) {
    statements
}
```


```{r}
for (j in 1:5)
{
  print(j^2)
}
```

Repeat the loop saving the resuls in a vector `x`. 

```{r}
n = 5
x = NULL  # creates a NULL object
for (j in 1:n)
{
  x[j] = j^2
}
x
```

Let's use a for loop to estimate the average of squaring the result of a roll of a dice.

```{r}
nsides = 6
ntrials = 1000
trials = NULL
for (j in 1:ntrials)
{
  trials[j] = sample(1:nsides,1)  # We get one sample at a time
}
mean(trials^2)
```

**Example:** stop on condition and print error message

```{r,eval=FALSE}
x <- 1:10
z <- NULL
for(i in seq(along=x)) {
    if (x[i]<5) {
        z <- c(z,x[i]-1) 
    } else {
        stop("values need to be <5")
    }
}
## Error: values need to be <5
z
## [1] 0 1 2 3
```



## `while`

Similar to `for` loop, but the iterations are controlled by a conditional statement.

```{r}
z <- 0
while(z < 5) {
    z <- z + 2
    print(z) 
}
```

## `apply` loop family


For Two-Dimensional Data Sets: apply

**Syntax:**

```
apply(X, MARGIN, FUN, ARGs)
```

`X`: `array`, `matrix` or `data.frame`; `MARGIN`: 1 for rows, 2 for columns, `c(1,2)` for both; `FUN`: one or more functions; `ARGs`: possible arguments for function.

```{r, eval=FALSE}
## Example for applying predefined mean function
apply(mtcars[,1:3], 1, mean)

## With custom function
x <- 1:10
test <- function(x) { # Defines some custom function
    if(x < 5) {
        x-1
    } else {
        x / x
    }
} 

apply(as.matrix(x), 1, test) 

## Same as above but with a single line of code
apply(as.matrix(x), 1, function(x) { if (x<5) { x-1 } else { x/x } })
```

**For Ragged Arrays: `tapply`**

Apply a function to each cell of a ragged array, that is to each (non-empty) group of values given by a unique combination of the levels of certain factors.

```{r,eval=TRUE}
## Computes mean values of vector agregates defined by factor
tapply(as.vector(mtcars$mpg), factor(mtcars$cyl), mean)

## The aggregate function provides related utilities
aggregate(mtcars[,c(1,3,4)], list(mtcars$cyl), mean)
```


**For Vectors and Lists: `lapply` and `sapply`**

Both apply a function to vector or list objects. The function `lapply` returns a list, while `sapply` attempts to return the simplest data object, such as `vector` or `matrix` instead of `list`. 

*Syntax*

```
lapply(X,FUN)
sapply(X,FUN)
```

```{r, echo=TRUE}
## Creates a sample list
mylist <- as.list(mtcars[,c(1,4,6)])
mylist
```

Compute sum of each list component and return result as list

```{r}
lapply(mylist, sum)
```

Compute sum of each list component and return result as vector

```{r}
sapply(mylist, sum)
```

## Other Loops

**Repeat Loop**

*Syntax*

`repeat` statements

Loop is repeated until a break is specified. This means there needs to be a second statement to test whether or not to break from the loop.

*Example:*
```
z <- 0
repeat {
    z <- z + 1
    print(z)
    if(z > 100) break()
}
```

## Improving Speed Performance of Loops

Looping over very large data sets can become slow in `R`. However, this limitation can be overcome by eliminating certain operations in loops or avoiding loops over the data intensive dimension in an object altogether. The latter can be achieved by performing mainly vector-to-vector or matrix-to-matrix computations which run often over 100 times faster than the corresponding `for()` or `apply()` loops in `R`. For this purpose, one can make use of the existing speed-optimized R functions (e.g.: `rowSums`, `rowMeans`, `table`, `tabulate`) or one can design custom functions that avoid expensive `R` loops by using vector- or matrix-based approaches. Alternatively, one can write programs that will perform all time consuming computations on the C-level.


1. Speed comparison of `for` loops with an append versus and inject step

```{r,eval=FALSE}
N <- 1e6
myMA <- matrix(rnorm(N), N, 10, dimnames=list(1:N, paste("C", 1:10, sep="")))
results <- NULL
system.time(for(i in seq(along=myMA[,1])) 
            results <- c(results, mean(myMA[i,])))

results <- numeric(length(myMA[,1]))
system.time(for(i in seq(along=myMA[,1])) 
            results[i] <- mean(myMA[i,]))
```
The inject approach is 20-50 times faster than the append version.

2. Speed comparison of `apply` loop versus `rowMeans` for computing the mean for each row in a large matrix:

```{r,eval=FALSE}
system.time(myMAmean <- apply(myMA, 1, mean))
system.time(myMAmean <- rowMeans(myMA))
```

The `rowMeans` approach is over 200 times faster than the `apply` loop.




<!-- http://manuals.bioinformatics.ucr.edu/home/programming-in-r#TOC-Control-Structures -->


# Probability distributions

## Binomial distribution $Bin(n,p)$
The binomial distribution is a discrete probability distribution. It describes the outcome of $n$ independent trials in an experiment. Each trial is assumed to have only two outcomes, either success or failure. If the probability of a successful trial is $p$, then the probability of having $k$ successful outcomes in an experiment of $n$ independent trials is given by the **probability mass function**:. 

$$
f(k,n,p) = \mbox{Pr}(X=k)=\binom{n}{k} p^k (1-p)^{n-k}, \quad k=0,1,2,...,n
$$

The **cumulative distribution function** can be expressed as:

$$
F(k;n,p) = \mbox{Pr}(X\leq k) = \sum_{i=0}^{k}\binom{n}{i} p^i (1-p)^{n-i}
$$
```{r, echo=FALSE,fig.width=10,fig.height=8}
library(RColorBrewer)
cols <- brewer.pal(4,"Set1")
sizes <- c(20,20,40)
probs <- c(0.5,0.7,0.5)
x <- seq(0,40,by=1)
pdfsimul <- matrix(NA,length(x),length(sizes))
cumsimul <- matrix(NA,length(x),length(sizes))
for(i in 1:3){
  pdfsimul[,i] <- dbinom(x,size=sizes[i],prob=probs[i])
  cumsimul[,i] <- pbinom(x,size=sizes[i],prob=probs[i])
}
par(mfrow=c(1,2))
matplot(x,pdfsimul,t='h',lty=1,lwd=2,col=cols,xlab="x",ylab="P(X=k)",main="Prob Mass Function")
legend("left",lty=1,legend=c("p=0.5 and N=20","p=0.7 and N=20","p=0.5 and N=40"),col=cols,lwd=2,cex=.75,horiz=FALSE, inset=0.5,box.lwd=0)
matplot(x,cumsimul,pch=8,lty=1,lwd=1,col=cols,xlab="x",ylab=expression(P(X=x)))
legend("left",pch=8,legend=c("p=0.5 and N=20","p=0.7 and N=20","p=0.5 and N=40"),col=cols,cex=.75,horiz=FALSE, inset=0.5,box.lwd=0)
```

with *mean* $np$ and *variance* $np(1-p)$.



**Question:**

Suppose there are twelve multiple choice questions in an Maths class quiz. Each question has five possible answers, and only one of them is correct. Find the probability of having four or less correct answers if a student attempts to answer every question at random. 

<!--
*Solution*

Since only one out of five possible answers is correct, the probability of answering a question correctly by random is $1/5=0.2$. We can find the probability of having exactly 4 correct answers by random attempts as follows. 

```{r}
p = 1/5
n = 12
k = 4
dbinom(k,size=n,prob=0.2)
```

To find the probability of having four or less correct answers by random attempts, we apply the function `dbinom` with `k=0,1,2,4`.
```{r}
prob <- NULL
for(k in 0:4){
prob <- c(prob,dbinom(k,n,p))
prob
}
prob
sum(prob)

# or simply
sum(dbinom(0:4,n,p))
```

Alternative, we can use the cumulative probability function for the binomial distribution `pbinom`
```{r}
pbinom(4,size=n,prob=0.2)
```

**Answer:** the probability of four or less questions answered correctly by random in a twelve question multiple choice quiz is 92.7%. 
-->

What is the probability of 2 or 3 questions answered correctly?
<!--
```{r}
sum(dbinom(2:3,n,p))
```
-->

**Question:** 

Suppose company **A** manufactures a product **B** which have probability 0.005 of being defective. Suppose product B is shipped in cartons containing 25 B items. What is the probability that a randomly chosen carton contains exactly one defective product? What is the probability that a randomly chosen carton contains no more than one defective widgit? 

**Solutions [here](IntroSM_sol.html)**

## Poisson distribution $Pois(\lambda)$

The Poisson distribution is the probability distribution of independent event occurrences in an interval. If $\lambda$ is the mean occurrence per interval, then the probability of having $k$ occurrences within a given interval is the probability mass function given by:

$$
\mbox{Pr}(\mbox{$k$ events in interval}) = \frac{\lambda^k e^{-\lambda}}{k!}
$$

The **cumulative density function** for the Poisson cumulative probability function is 
$$
P(X\leq x ~|~\lambda ) = \frac{e^{-\lambda} \lambda ^x}{x!}\quad \mbox{for $x=0,1,2,...$}
$$


```{r, echo=FALSE,fig.width=10,fig.height=8}
library(RColorBrewer)
cols <- brewer.pal(4,"Set1")
la <- c(1,4,10)
x <- seq(0,40,by=1)
pdfsimul <- matrix(NA,length(x),length(sizes))
cumsimul <- matrix(NA,length(x),length(sizes))
for(i in 1:3){
  pdfsimul[,i] <- dpois(x,lambda=la[i])
  cumsimul[,i] <- ppois(x,lambda=la[i])
}
par(mfrow=c(1,2))
matplot(x,pdfsimul,t='b',pch=8,lwd=2,col=cols,xlab="x",ylab="P(X=k)",main="Prob Mass Function")
legend("left",lty=1,legend=c(expression(lambda==1),expression(lambda==4),expression(lambda==10)),col=cols,lwd=2,cex=.75,horiz=FALSE, inset=0.5,box.lwd=0)
matplot(x,cumsimul,pch=8,lty=1,lwd=1,col=cols,xlab="x",ylab=expression(P(X<=k)), main="Cumulative Distribution Function")
legend("left",pch=8,legend=c(expression(lambda==1),expression(lambda==4),expression(lambda==10)),col=cols,cex=.75,horiz=FALSE, inset=0.5,box.lwd=0)
```

**Question:** 

Suppose the number of individual plants of a given species we expect to find in a one meter square quadrat follows the Poisson distribution with mean $\lambda= 10$. Find the probability of finding
exactly $12$ individuals.


**Question:** 

If there are twelve cars crossing a bridge per minute on average, find the probability of having seventeen or more cars crossing the bridge in a particular minute. 


**Solutions [here](IntroSM_sol.html)**


## Aproximation of Binomial as Poisson

**Example**

Five percent (5%) of Christmas tree light bulbs manufactured by a company are defective. The company's Quality Control Manager is quite concerned and therefore randomly samples 100 bulbs coming off of the assembly line. Let X denote the number in the sample that are defective. What is the probability that the sample contains at most three defective bulbs?

```{r}
p = 0.05
k = 3
n = 100
pbinom(k,size=n,prob=p)
```

It can be demonstrated that the Binomial distribution can be approximated with the Poisson probability mass function when $n$ is large. Using the Poisson distribution, the mean $\lambda = np$

```{r}
lambda <- n*p
sum(dpois(0:3,lambda))
```

It is important to keep in mind that the Poisson approximation to the binomial distribution works well only when $n$ is large and $p$ is small. In general, the approximation works well if $n \geq 20$ and $p\leq0.05$, or if $n\geq 100$ and $p\leq 0.10$.

## Exponential distribution $Exp(\lambda)$

The exponential distribution is the probability distribution that describes the time between events in a Poisson process, i.e. a process in which events occur continuously and independently at a constant average rate. It is a particular case of the gamma distribution. It is the continuous analogue of the geometric distribution, and it has the key property of being memoryless. In addition to being used for the analysis of Poisson processes, it is found in various other contexts.


 The probability density function (pdf) of an exponential distribution as
$$
f(x;\lambda) =  \lambda \exp(-\lambda x)
$$

where $\lambda>0$ is the event rate (also known as rate parameter, arrival rate, death rate, failure rate, transition rate). The exponential variable $x \in [0,\infty)$
```{r,echo=FALSE, fig.width=10,fig.height=8}
library(RColorBrewer)
cols <- brewer.pal(4,"Set1")
pdfsimul <- matrix(NA,200,3)
cumsimul <- matrix(NA,200,3)
la <- c(.5,1,1.5)
for(i in 1:3){
  pdfsimul[,i] <- dexp(seq(0,5,l=200),rate=la[i])
  cumsimul[,i] <- pexp(seq(0,5,l=200),rate=la[i])
}
par(mfrow=c(1,2))
matplot(seq(0,5,l=200),pdfsimul,t='l',lty=1,lwd=2,col=cols,xlab="x",ylab="",main="Probability Density Function")
legend("left",lty=1,legend=c(expression(lambda==0.5),expression(lambda==1.0),expression(lambda==1.5)),col=cols,lwd=2,cex=1.,horiz=FALSE, inset=0.5,box.lwd=0)
matplot(seq(0,5,l=200),cumsimul,t='l',lty=1,lwd=2,col=cols,xlab="x",ylab=expression(P(X<=x)),main="Cumulative Distribution Function")
legend("left",lty=1,legend=c(expression(lambda==0.5),expression(lambda==1.0),expression(lambda==1.5)),col=cols,lwd=2,cex=1.,horiz=FALSE, inset=0.5,box.lwd=0)
```

Cumulative distribution function of the exponential distribution is
$$
F(x) = \mbox{Pr}(X\leq x) = 
  \left\{
    \begin{array}{lcc}
      1- e^{-\lambda x} & & x\geq 0 \\
      0                 & & x < 0
    \end{array}
  \right.
$$

Mean $\mathbb{E}(X) = 1/\lambda$, and $\mathbb{V}ar(X) = 1/\lambda^2$.

**Question:**

Suppose that the amount of time one spends in a bank is exponentially distributed with mean 10 minutes, $\lambda=1/10$. 

- What is the probability that a customer will spend more than 15 minutes in the bank? 
- What is the probability that a customer will spend more than 15 minutes in the bank given that he is still in the bank
after 10 minutes?


**Solutions [here](IntroSM_sol.html)**


## The Normal distribution $\mathcal{N}(\mu,\sigma^2)$

The probability density function of the Normal distribution is:

$$
f(x | \mu,\sigma^2) = \frac{1}{\sqrt{2\sigma^2\pi}} e ^{-\frac{(x-\mu)^2}{2\sigma^2}},
$$
where

- $\mu$ is the mean of the distribution (also the median and the mode).
- $\sigma$ is the standard deviation ($\sigma>0$).
- $\sigma^2$ is the variance.

The process to standardized Normal distribution consists in transforming the Normal variable $N(\mu,\sigma)$ to $N(0,1)$, i.e.
$$
Z = \frac{X-\mu}{\sigma} \sim N(0,1)
$$

```{r, echo=FALSE,fig.width=10,fig.height=8}
library(RColorBrewer)
cols <- brewer.pal(4,"Set1")
 means <- c(-2,0,0,0)
sigmas <- sqrt(c(.5,5,1,.2))
pdfsimul <- matrix(NA,200,4)
cumsimul <- matrix(NA,200,4)
x <- seq(-5,5,l=200)
for(i in 1:4){
  pdfsimul[,i] <- dnorm(x,mean=means[i],sd=sigmas[i])
  cumsimul[,i] <- pnorm(x,mean=means[i],sd=sigmas[i])
}
par(mfrow=c(1,2))
matplot(x,pdfsimul,t='l',lty=1,lwd=2,col=cols,xlab="x",ylab="", main="Probability Density Function")
legend(1.55,0.8,lty=1,legend=c(expression(mu==-2,sigma^2==0.5),expression(mu==0,sigma^2==5),expression(mu==0,sigma^2==1),expression(mu==0,sigma^2==0.2)),col=c(cols[1],"white",cols[2],"white",cols[3],"white",cols[4],"white"),lwd=2,cex=1.,horiz=FALSE, inset=0.5,box.lwd=0)
matplot(x,cumsimul,t='l',lty=1,lwd=2,col=cols,xlab="x",ylab=expression(P(X<=x)), main ="Cumulative Distribution Function")
legend(1.55,0.6,lty=1,legend=c(expression(mu==-2,sigma^2==0.5),expression(mu==0,sigma^2==5),expression(mu==0,sigma^2==1),expression(mu==0,sigma^2==0.2)),col=c(cols[1],"white",cols[2],"white",cols[3],"white",cols[4],"white"),lwd=2,cex=1.,horiz=FALSE, inset=0.5,box.lwd=0)
```


**Question:**

$X$ is a normally distributed variable with mean $\mu = 30$ and standard deviation $\sigma = 4$. Find

a) $P(x<40)$

b) $P(x>21)$

c) $P(30<x<35)$

**Question:**

Entry to a certain University is determined by a national test. The scores on this test are normally distributed with a mean of 500 and a standard deviation of 100. Tom wants to be admitted to this university and he knows that he must score better than at least 70% of the students who took the test. Tom takes the test and scores 585. Will he be admitted to this university?



**Solutions [here](IntroSM_sol.html)**


<!-- ## Uniform distribution -->

<!-- ## Gamma distribution -->

<!-- ## Beta distribution -->


<!-- # Central Limit Theorem -->

<!-- ```{r} -->
<!-- library(TeachingDemos) -->
<!-- clt.examp(5) -->
<!-- clt.examp(50) -->
<!-- ``` -->

<!-- # Estimation -->

## Exercises

1. A dice is thrown at random. What is the expectation of number on it? (Or) If x denotes the number of points on a dice, find the expectation and the variance of x.

```{r}
x = 1:6
prob <- 1/6

 E  <- sum(x*rep(prob,length(x)))
 
 E2 <- E^2
 Ex2 <- sum(x^2*rep(prob,length(x)))
Var <- Ex2-E2
```

2. If a person gains or loses an amount equal to the number appearing when a balanced die is rolled once, according to whether the number is even or odd, how much money can be expect per game in the long run? 


Let $x$ indicate the amount that the person wins 

The amount gained by the person would be

-  `- Rs. 1` if the dice shows up ONE
-  `+ Rs. 2` if the dice shows up TWO
-  `- Rs. 3` if the dice shows up THREE
-  `+ Rs. 4` if the dice shows up FOUR
-  `- Rs. 5` if the dice shows up FIVE
-  `+ Rs. 6` if the dice shows up SIX


```{r}
x = c(1:6)*c(-1,1,-1,1,-1,1)
pr <- rep(1/6,6)
 Ex <- sum(x*pr)
Ex2 <- sum(x^2*pr)
Var <- Ex2-Ex^2
Ex
Var
```


# Statistical Inference

Statistical inference means drawing conclusions based on data. There are many ways of performing inference including statistical modeling, data oriented strategies and explicit use of designs and randomization in analyses. Furthermore, there are broad theories (frequentists, Bayesian, likelihood, design based, ...) and numerous complexities (missing data, observed and unobserved confounding, biases) for performing inference. This section presents the fundamentals of inference in a practical approach for getting things done in order to use statistical inference for making informed choices in analyzing data.


<!-- **Example:** -->

<!-- Consider three sets of observations on ten patients at an asylum. The observations recorded are the average increase in the hours of sleep given three sleep-inducing drugs, compared to a control average where no medication was given. -->

<!-- ```{r} -->
<!-- extra.hyoscyamine <- c(0.7, -1.6, -0.2, -1.2, -0.1, 3.4, 3.7, 0.8, 0.0, 2.0) -->
<!-- extra.laevorotatory <- c(1.9, 0.8, 1.1, 0.1, -0.1, 4.4, 5.5, 1.6, 4.6, 3.4) -->
<!-- extra.racemic <- c(1.5, 1.4, 0.0, -0.7, 0.5, 5.1, 5.7, 1.5, 4.7, 3.5) -->
<!-- ``` -->



<!-- **First question.**  Consider the `extra.hyoscyamine` observations, which represents the extra hours of sleep on average when given the hyoscyamine drug.  The mean increase is -->

<!-- ```{r} -->
<!-- mean(extra.hyoscyamine) -->
<!-- ``` -->

<!-- However, we are not really interested in these 10 particular patients, but in the e ect of the drug in the *general population*.  To make any statements about that, we need to  rst link this particular sample to the population. -->



<!-- This is done by hypothesizing a statistical model.  In this simple case, our model needs just one univariate distribution; we will pretend that we have planned the experiment but not yet observed the data, and denote the $n=10$ observations we will see by the symbols $X_1,X_2,...,X_n$.  We will assume that these quantities are independent random variables coming from a common but unknown distribution $F$.  The only unknown component of our model is -->
<!-- $F$, which we refer to as the *parameter* of our model.  The link between the model and the actual observed data is completed by assuming that the observed data is one realization of these random variables.  If we repeated the experiment with $n$ other patients, the observed numbers would be different, but they would be realizations from the same distribution $F$. -->

<!-- It is difficult to infer much about the unknown distribution $F$ in this model. However, we may be interested in the population mean $\mu$ -->
<!-- $$ -->
<!--     \mu = E(X_i) =  \int_{-\infty}^{\infty} x f(x)dx  -->
<!-- $$ -->
<!-- where $f(x)$ is the density function of the distribution $F$. A common-sense estimator of $\mu$ is the sample mean -->
<!-- $$ -->
<!--  \bar{X} = \frac{1}{n} \sum_{i=1}^{n} X_i -->
<!-- $$ -->
<!-- is it self a random variable, i.e. it would have taken a different value if a different set of 10 patients had been selected from the experiment. The probability distribution of $E(\bar{X})$ (which depends on $F$) has its own mean and variance. $\bar{X}$ is *unbiased* because $E[\bar{X}] = \mu$ and has lower variance than any other (linear) unbiased estimator of $\mu$. -->


<!-- **Second question:** In our observed sample, $\bar{X}$ has the value 0.75.  Does this mean is exactly equal to $0.75$? Of course not.  Can we at least say that is positive (that is, giving hyoscyamine is better than giving no drug at all)?  Even that is not necessarily true. -->

<!-- To see why, let us do some simulation.  It is expensive to perform experiments in real life, but it is cheap to do them in a computer.  Consider our model.  We do not know the parameter $F$, but let us suppose for a moment that $F$ was the standard Normal distribution $N(0,1)$.  -->

<!-- ```{r} -->
<!-- mean(rnorm(10)) -->
<!-- ``` -->

<!-- We can repeat this experiment several times to get -->
<!-- ```{r} -->
<!-- replicate(20,mean(rnorm(20))) -->
<!-- ``` -->

<!-- As we can see, $\bar{X}$ is sometimes positive even when the true $F$ has $\mu=0$. Thus, the fact that $\bar{X}$ is positive in our experiment does not imply that $\mu > 0 $.  There is not much more we can say about this problem unless we make further model assumptions. -->


<!-- **A more specific model**. Our previous model made very few assumptions:  only that all observations are independent and come from the same distribution. Not much inference can be done in such a general setup.  We will now make a much more specific model:  we will assume that $F$ is a Normal distribution, -->
<!-- with mean $\mu$ and variance $\sigma^2$; that is, -->
<!-- $$ -->
<!--     X_i \sim N(\mu,\sigma^2) -->
<!-- $$ -->





## Interval estimation

It is a common requirement to efficiently estimate population parameters based on simple random sample data. 


```{r}
library(MASS)
?survey
head(survey)
```

**Point estimate of population mean**

For any particular random sample, we can always compute its sample mean. Although most often it is not the actual population mean, it does serve as a good point estimate. For example, in the data set survey, the survey is performed on a sample of the student population. We can compute the sample mean and use it as an estimate of the corresponding population parameter.

**Problem:**  Find a point estimate of mean university student height with the sample data from survey.

```{r}
mean(survey$Height)
mean(survey$Height,na.rm=TRUE) 
# or
mean(na.omit(survey$Height))

```

After we found a point estimate of the population mean, we would need a way to quantify its accuracy. 


### Interval Estimate of Population Mean (with known variance)


Let us denote the $100~(1-\alpha/2)$ percentile of the standard normal distribution as $z_{\alpha/2}$. For random sample of sufficiently large size, the end points of the interval estimate at $(1-\alpha/2)$ confidence level is given as follows: 
$$
  \bar{x} \pm \frac{\sigma}{\sqrt{n}}
$$

**Problem:** assume the population standard deviation $\sigma$ of the student height in survey is 9.48. Find the margin of error and interval estimate at 95% confidence level.

```{r}
x <- na.omit(survey$Height)
n <- length(x)
sigma <- 9.48
sem = sigma/sqrt(n)  # Standard error of the mean
sem
```

Since there are two tails of the normal distribution, the 95% confidence level would imply the 97.5th percentile of the normal distribution at the upper tail. Therefore, $z_{\alpha/2}$ is given by `qnorm(.975)`. We multiply it with the standard error of the mean `sem` and get the margin of error. 

```{r}
E <- qnorm(0.975)*sem 
E  # margin of error
xbar <- mean(x,na.rm = TRUE)
xbar + c(-E,E)
```

Alternatively, we can use `z.test`

```{r}
library(TeachingDemos)
z.test(x,sd=sigma)
```

Assuming the population standard deviation $\sigma$ being 9.48, the margin of error for the student height survey at 95% confidence level is `r E` centimeters. The confidence interval is between `r z.test(x,sd=sigma)$conf.int[1]` and  `r z.test(x,sd=sigma)$conf.int[2]` centimeters. 


### Interval Estimate of Population Mean (with unknown variance)


```{r}
s = sd(x)
SE <- s/sqrt(n)
E = qt(.975, df=n-1)*SE; E
xbar + c(-E, E) 

# or 

t.test(x)
```

Without assumption on the population standard deviation, the margin of error for the student height survey at 95% confidence level is 1.3429 centimeters. The confidence interval is between 171.04 and 173.72 centimeters. 



#### Sampling Size of Population Mean

The quality of a sample survey can be improved by increasing the sample size. The formula below provide the sample size needed under the requirement of population mean interval estimate at $(1-\alpha)$ confidence level, margin of error $E$, and population variance $\sigma^2$. Here, $z_{\alpha-2}$ is the $100(1 -\alpha/2)$ percentile of the standard normal distribution. 

$$
    n = \frac{(z_{\alpha/2})^2 \sigma^2}{E^2}
$$


**Problem:**

Assume the population standard deviation $\sigma$ of the student height in `survey` is 9.48. Find the sample size needed to achieve a 1.2 centimeters margin of error at 95% confidence level. 


```{r}
zstar = qnorm(.975) 
sigma = 9.48 
E = 1.2 
zstar^2 *sigma^2/ E^2 
```


Based on the assumption of population standard deviation being 9.48, it needs a sample size of 240 to achieve a 1.2 centimeters margin of error at 95% confidence level. 


### Interval estimates of population proportion

**Point estimate of population proportion**


Multiple choice questionnaires in a survey are often used to determine the the proportion of a population with certain characteristic. For example, we can estimate the proportion of female students in the university based on the result in the sample data set `survey`.

**Problem:**  Find a point estimate of the female student proportion from survey.

```{r}
library(MASS)
gender.response <- na.omit(survey$Sex) # filter out NA's
n <- length(gender.response)
table(gender.response)
```

To find out the number of female students, we compare `gender.response`

```{r}
k <- sum(gender.response == "Female") 
# or 
k <- table(gender.response)[1]

pbar <- k/n; pbar
```


The point estimate of the female student proportion in survey is 50%. 



In order to compute the confidence interval of the estimated proportion, let us denote the $100(1-\alpha/2)$ percentile of the standard normal distribution as $z_{\alpha/2}$. If the samples size $n$ and population proportion $p$ satisfy the condition that $np \geq 5$ and $n(1-p) \geq 5$, than the end points of the interval estimate at $(1-\alpha)$ confidence level is defined in terms of the sample proportion as follows. 

$$
      \bar{p} = \pm z_{\alpha/2} \sqrt{\frac{\bar{p}(1-\bar{p})}{n}} 
$$

We use the `prop.test` function for direct calculation

```{r}
prop.test(k,n,conf.level = 0.95)
```

At 95% confidence level, between 43.6% and 56.3% of the university students are female, and the margin of error is 6.4%. 




#### Sampling Size of Population proportion

The quality of a sample survey can be improved by increasing the sample size. The formula below provide the sample size needed under the requirement of population proportion interval estimate at $(1 -\alpha)$ confidence level, margin of error $E$, and planned proportion estimate $p$. Here, $z_{\alpha/2}$ is the $100(1-\alpha/2)$ percentile of the standard normal distribution. 


$$
   n  = \frac{(z_{\alpha/2})^2 p (1-p)}{E^2}
$$

```{r}
zstar = qnorm(.975) 
p = 0.5 
E = 0.05 
zstar^2 * p * (1-p) / E^2 
```

With a planned proportion estimate of 50% at 95% confidence level, it needs a sample size of 385 to achieve a 5% margin of error for the survey of female student proportion. 



## Inference about two populations

It is often necessary to draw conclusion on the difference between two populations by their data samples. In the following tutorials, we discuss how to estimate the difference of means and proportions between two normally distributed data populations. 

### Population mean between two matches samples

Two data samples are matched if they come from repeated observations of the same subject. Here, we assume that the data populations follow the normal distribution. Using the paired t-test, we can obtain an interval estimate of the difference of the population means.


```{r}
library(MASS)
data(immer)
?immer
head(immer)
```


**Problem:**

Assuming that the data in `immer` follows the normal distribution, find the 95% confidence interval estimate of the difference between the mean barley yields between years 1931 and 1932. 

```{r}
t.test(immer$Y1, immer$Y2, paired=TRUE) 
```

**Answer:**

Between years 1931 and 1932 in the data set `immer`, the 95% confidence interval of the difference in means of the barley yields is the interval between 6.122 and 25.705. 



## Population Mean Between Two Independent Samples

Two data samples are independent if they come from unrelated populations and the samples does not affect each other. Here, we assume that the data populations follow the normal distribution. Using the unpaired t-test, we can obtain an interval estimate of the difference between two population means. 

*Example:*

In the data frame column mpg of the data set `mtcars`, there are gas mileage data of various 1974 U.S. automobiles. `am` variable indicates the transmission type of the automobile model (0 = automatic, 1 = manual). 

In particular, the gas mileage for manual and automatic transmissions are two independent data populations.

**Problem:**

Assuming that the data in `mtcars` follows the normal distribution, find the 95% confidence interval estimate of the difference between the mean gas mileage of manual and automatic transmissions. 


```{r}
t.test(mpg ~ am, data=mtcars) 
```

In `mtcars`, the mean mileage of automatic transmission is 17.147 `mpg` and the manual transmission is 24.392 `mpg`. The 95% confidence interval of the difference in mean gas mileage is between 3.2097 and 11.2802 `mpg`. 

## Comparison of Two Population Proportions

A survey conducted in two distinct populations will produce different results. It is often necessary to compare the survey response proportion between the two populations. Here, we assume that the data populations follow the normal distribution.

**Example:**

In the built-in data set named quine, children from an Australian town is classified by ethnic background, gender, age, learning status and the number of days absent from school. 

```{r}
library(MASS)
data(quine)
?quine
head(quine)
```

Column `Eth` indicates whether the student is Aboriginal or Not ("A" or "N"), and the column `Sex` indicates Male or Female ("M" or "F").

```{r}
table(quine$Eth,quine$Sex)
```

**Problem:**

Assuming that the data in quine follows the normal distribution, find the 95% confidence interval estimate of the difference between the female proportion of Aboriginal students and the female proportion of Non-Aboriginal students, each within their own ethnic group.

**Solution**

We apply the `prop.test function to compute the difference in female proportions. The Yates's continuity correction is disabled for pedagogical reasons. 

```{r}
prop.test(table(quine$Eth, quine$Sex), correct=FALSE) 
```

The 95% confidence interval estimate of the difference between the female proportion of Aboriginal students and the female proportion of Non-Aboriginal students is between -15.6% and 16.7%. 


## Goodness-of-Fit

Many statistical quantities derived from data samples are found to follow the Chi-squared distribution. Hence we can use it to test whether a population fits a particular theoretical probability distribution.


## Chi-squared Test of Independence

Two random variables $x$ and $y$ are called independent if the probability distribution of one variable is not affected by the presence of another. Assume $f_{ij}$ is the observed frequency count of events belonging to both $i$-th category of x and $j$-th category of $y$. Also assume $e_{ij}$ to be the corresponding expected count if $x$ and $y$ are independent. The null hypothesis of the independence assumption is to be rejected if the p-value of the following Chi-squared test statistics is less than a given significance level $\alpha$.


$$
  \chi^2 = \sum_{i,j}\frac{(f_i - e_i)^2}{e_i}
$$


**Example:**

In the built-in data set `survey`, the `Smoke` column records the students smoking habit, while the `Exer` column records their exercise level. The allowed values in Smoke are "Heavy", "Regul" (regularly), "Occas" (occasionally) and "Never". As for Exer, they are "Freq" (frequently), "Some" and "None". 

```{r}
library(MASS)
data(survey)
tbl <- table(survey$Smoke,survey$Exer)
tbl
```

**Problem:**

Test the hypothesis whether the students smoking habit is independent of their exercise level at $0.05$ significance level. 

```{r,warning=FALSE}
chi2test <- chisq.test(tbl) 
chi2test
```

As the p-value is `r chi2test$p.value` greater than the 0.05 significance level, we do not reject the null hypothesis that the smoking habit is independent of the exercise level of the students.


The warning message found in the solution above is due to the small cell values in the contingency table. To avoid such warning, we combine the second and third columns of `tbl`, and save it in a new table named `ctbl`. Then we apply the `chisq.test` function against `ctbl` instead. 

```{r}
ctbl <- cbind(tbl[,"Freq"], tbl[,"None"] + tbl[,"Some"])
ctbl
chi2test <- chisq.test(ctbl)
chi2test
```
The p-value is `r chi2test$p.value` also greater than the 0.05 significance level.


## Mann-Whitney U test

Also known as Mann-Whitney-Wilcoxon (MWW), Wilcoxon rank-sum test, or Wilcoxon-Mann-Whitney test is a non-parametric test of the null hypothesis that two samples come from the same sample population against an alternative hypothesis, especially that a particular population tends to have larger values than the other. Is the alternative test to the independent sample t-test. As a non-parametric test, it does not assume any assumptions related to the distribution. Hence, we can decide whether the population distributions are identical without assuming them to follow the normal distribution. 



There are, however, some assumptions that are assumed:

  1. The sample drawn from the population is random.
  2. Independence within the samples and mutual independence is assumed.
  3. Ordinal measurement scale is assumed.


Mann-Whitney U test is used for every field, but in frequently used in psychology, medical/nursing and business.  For example, in psychology, it is used to compare attitude or behavior, etc.  In medicine, it is used to know the effect of two medicines and whether they are equal or not.  It is also used to know whether or not a particular medicine cures the ailment or not.  In business, it can be used to know the preferences of different people and it can be used to see if that changes depending on location.



**Example**
Consider the `mtcars` data set. We are aim to find out whether automatic transmission cars are less fuel efficient compared to manual transmission cars. Since 1950, most cars sold in North America have been available with an automatic transmission. 

The `mtcars` dataset is from the 1974 "Motor Trend US" magazine, consisting of fuel consumption measurement (mpg) and 10 different aspects of automoblie design and performance for 32 automobiles (1973-74 models).

We first plot the data (mpg vs transmission)

either with a boxplot
```{r}
boxplot(mpg~am,data=mtcars,names=c("automatic","manual"),ylab="mpg",xlab="Transmission")
```

or with a bar chart (with error bars)

```{r, echo=FALSE}
##### Step 1. reorganize the data in a correct format for statistical analysis
aggmpg <- tapply(mtcars$mpg, mtcars$am, mean, na.rm = TRUE)
sdmpg <- tapply(mtcars$mpg, mtcars$am, sd, na.rm = TRUE)
aggam <- unique(factor(c("automatic", "manual")))
##### Step 2. Plot a barchart
barmpg <- barplot(aggmpg, names = aggam, ylim = c(0, 35), main = paste("Average miles per gallon by transmission type"), 
    space = 0.3, axes = TRUE, axis.lty = 10, col = "white", ylab = "mpg")
# put the plot in a box
box()
# plot the vertical lines of the error bars
segments(barmpg, aggmpg - sdmpg, barmpg, aggmpg + sdmpg, lwd = 2)
# now plot the horizontal bounds for the error bars the lower bar
segments(barmpg - 0.05, aggmpg - sdmpg, barmpg + 0.05, aggmpg - sdmpg, lwd = 1)
# the upper bar
segments(barmpg - 0.05, aggmpg + sdmpg, barmpg + 0.05, aggmpg + sdmpg, lwd = 1)

```


We run some statistical tests to compare mpg between automatic- and manual-transmitted cars. 


The first one is a t-test, assuming that the mileage data have a normal distribution. The test result clearly shows that the manual transmission cars are more gas-efficient than automatic transmission cars (miles per gallon: 24.39 versus 17.15). 


```{r}
t.test(mpg ~ factor(am), data = mtcars)
```

However, the normality assumption could be quite strong, given the fact that we do not know the true underlying distributions of `mpg` data. Moreover, the number of data points are not large enough to apply the central limit theorem. Therefore, a more conservative test would be the Wilcoxon test, with the null hypothesis that the gas mileage data of manual and automatic transmissions are from identical populations.

```{r}
wilcox.test(mpg ~ am, data = mtcars)
```

A non-parametric, Wilcoxon test also rejects the null hypothesis that the mileage data of the manual and automatic transmissions are from the same population (indicating a difference).






<!-- ------------------------------- -->



<!-- We wish to test a null hypothesis ($H_0$) against an alternative hypothesis ($H_1$) using a dataset. The two hypotheses specify two statistical models for the process that produced the data.  The alternative hypothesis is what we expect to be true if the null hypothesis is false.  Wecannot prove that the alternative hypothesis is true but we may be able to demonstrate that the alternative is much more plausible than the null hypothesis given the data. This demonstration is usually expressed in terms of a probability (a P-value) quantifying the strength of the evidence against the null hypothesis in favor of the alternative. -->

<!-- We ask whether the data appear to be consistent with the null hypothesis or whether it is -->
<!-- unlikely that we would obtain data of this kind if the null hypothesis were true, assuming -->
<!-- that at least one of the two hypotheses is true. We address this question by calculating the -->
<!-- value of a test statistic, i.e., a particular real-valued function of the data. To decide whether -->
<!-- the value of the test statistic is consistent with the null hypothesis, we need to know what -->
<!-- sampling variability to expect in our test statistic if the null hypothesis is true.  In other -->
<!-- words, we need to know the null distribution, the distribution of the test statistic when the -->
<!-- null hypothesis is true. In many applications, the test statistic is defined so that its null -->
<!-- distribution is a "named" distribution for which tables are widely accessible; e.g., the -->
<!-- standard normal distribution, the Binomial distribution with n = 100 and p = 1/2, the t -->
<!-- distribution with 4 degrees of freedom, the chi-square distribution with 23 degrees of -->
<!-- freedom, the F distribution with 2 and 20 degrees of freedom. -->

<!-- Now, given the value of the test statistic (a number), and the null distribution of the test -->
<!-- statistic (a theoretical distribution usually represented by a probability density), we want to -->
<!-- see whether the test statistic is in the middle of the distribution (consistent with the null -->
<!-- hypothesis) or out in a tail of the distribution (making the alternative hypothesis seem more -->
<!-- plausible).  Sometimes we will want to consider the right-hand tail, sometimes the left-hand -->
<!-- tail, and sometimes both tails, depending on how the test statistic and alternative hypothesis -->
<!-- are defined. Suppose that large positive values of the test statistic seem more plausible -->
<!-- under the alternative hypothesis than under the null hypothesis.  Then we want a measure -->
<!-- of how far out our test statistic is in the right-hand tail of the null distribution.  The P-value -->
<!-- provides a measure of this distance.  The P-value (in this situation) is the probability to the -->
<!-- right of our test statistic calculated using the null distribution. The further out the test -->
<!-- statistic is in the tail, the smaller the P-value, and the stronger the evidence against the null -->
<!-- hypothesis in favor of the alternative. -->
<!-- The P-value can be interpreted in terms of a hypothetical repetition of the study.  Suppose -->
<!-- the null hypothesis is true and a new dataset is obtained independently of the first dataset -->
<!-- but using the same sampling procedure. If the new dataset is used to calculate a new value -->
<!-- of the test statistic (same formula but new data), what is the probability that the new value -->
<!-- will be further out in the tail (assuming a one-tailed test) than the original value?  This -->
<!-- probability is the P-value. -->

<!-- The P-value is often incorrectly interpreted as the probability that the null hypothesis is -->
<!-- true.  Try not to make this mistake.  In a frequentist interpretation of probability, there is -->
<!-- nothing random about whether the hypothesis is true, the randomness is in the process -->
<!-- generating the data.  One can interpret "the probability that the null hypothesis is true" using -->
<!-- subjective probability, a measure of one's belief that the null hypothesis is true. One can then calculate this subjective probability by specifying a prior probability (subjective belief -->
<!-- before looking at the data) that the null hypothesis is true, and then use the data and the -->
<!-- model to update one's subjective probability.  This is called the Bayesian approach because -->
<!-- Bayes' Theorem is used to update subjective probabilities to reflect new information. -->
<!-- When reporting a P-value to persons unfamiliar with statistics, it is often necessary to use -->
<!-- descriptive language to indicate the strength of the evidence.  I tend to use the following -->
<!-- sort of language.  Obviously the cut-offs are somewhat arbitrary and another person might -->
<!-- use different language. -->


<!-- <center> -->

<!-- | $p$-value       |             Interpretation                                                                           |  -->
<!-- |:---------------:|:----------------------------------------------------------------------------------------------------:| -->
<!-- | $p> 0.10$       |  No evidence against the null hypothesis. The data appear to be consistent with the null hypothesis  | -->
<!-- | $0.05<p<0.10$   |    Weak evidence against the null hypothesis in favor of the alternative                             | -->
<!-- | $0.01<p<0.05$   | Moderate evidence against the null hypothesis in favor of the alternative.                           |   -->
<!-- | $0.001<p<0.01$  | Strong evidence against the null hypothesis in favor of the alternative                              |   -->
<!-- | $p<0.001$       | Very strong evidence against the null hypothesis in favor of the alternative                         |   -->

<!-- </center> -->

<!-- In using this kind of language, one should keep in mind the difference between statistical -->
<!-- significance and practical significance.  In a large study one may obtain a small P-value -->
<!-- even though the magnitude of the effect being tested is too small to be of importance (see -->
<!-- the discussion of power below).  It is a good idea to support a P-value with a confidence -->
<!-- interval for the parameter being tested. -->

<!-- ## Two sample tests -->

<!-- ### Two sample Z-test -->

<!-- Comparison of the means of two independent groups of samples, taken from two populations with *known* variance. -->

<!-- **Example:** -->
<!-- Is asked to compare the average heights of two groups. The first group (A) consists of individuals of Spanish nationality (the variance of the Italian population is 5); the second group is taken from individuals of German nationality (the variance of German population variance is 8.5). The data are given below: -->

<!-- ```{r} -->
<!-- sample.A = c(175, 168, 168, 190, 156, 181, 182, 175, 174, 179) -->
<!-- sample.B = c(185, 169, 173, 173, 188, 186, 175, 174, 179, 180) -->
<!-- ``` -->
<!-- $$Z=\frac{(\overline{x}_1-\overline{x}_2)-(\mu_1-\mu_2)}{\sqrt{\frac{\sigma_1^2}{n_1}+\frac{\sigma_2^2}{n_2}}}$$ -->

<!-- Since we have the variance of the population, we must proceed with a two sample Z-test. Even in this case is not avalilable in R a function to solve the problem, but we can easily create it ourselves. -->


<!-- ```{r} -->
<!-- z.test2sam = function(a, b, var.a, var.b){ -->
<!--    n.a = length(a) -->
<!--    n.b = length(b) -->
<!--    zeta = (mean(a) - mean(b)) / (sqrt(var.a/n.a + var.b/n.b)) -->
<!--    return(zeta) -->
<!-- } -->
<!-- ``` -->

<!-- The value of zeta is greater than the value of the critical value zeta tabulated for alpha equal to 0.05 (z-tabulated = 1.96 for a two-tailed test): then we reject the null hypothesis in favor of the alternative hypothesis. We conclude that the two means are significantly different. -->

<!-- To compute the $p$-value -->
<!-- ```{r} -->
<!-- z <- z.test2sam(sample.A,sample.B,5,8.5) -->
<!-- pvalue2sided <- 2*pnorm(-abs(z)) -->
<!-- pvalue2sided -->
<!-- ``` -->





<!-- **When is used:** to compare the means of two groups under the assumption that both samples are random, independent, and come from normally distributed population with unknow but equal variances. -->


# Linear models in `R` 


## Simple linear regression

- Regression is a statistical method used to predict the value of a response variable based on the values of a set of explanatory variables. 

- One very general form for the model would be

$$
      y = f(x_1,x_2,...,x_p) + \epsilon,
$$

where $f$ is some unknown function and $\epsilon$ is the error in this representation. Since we usually don't have enough data to try to estimate $f$ directly (*inverse problem*), we usually have to assume that it has some restricted form.


- Any statistical model attempts to approximate the response variable or dependent variable $y$ as a mathematical function of the explanatory variables or regressors $X$ (also called covariates or independent variables).


- The simplest and most common form is the **linear model (LM)**

$$
    y = \beta_0 + \beta_1 x_1 + \beta_2 x_z + \epsilon,
$$
where $\beta_i$ $i=0,1,2$ are *unknown* parameters. $\beta_0$ is called the intercept term. Hence, the problem is reduced to the estimation of four values rather than the complicated infinite dimensional $f$. 


- A simple linear model with a single exploratory variable is defined as:
$$
         \hat{y} = \beta_0 + \beta_1 x
$$

where $\hat y$ is the fitted values for $\beta_0$ (intercept) and $\beta_1$ (slope). Then for a given $x_i$ we obtain a $\hat{y}_i$ that approximates $y_i$


Let us create a toy example (with $p=1$):

```{r}
set.seed(1)
n <- 50 

x <- seq(1,n)
 beta0 <- 15
 beta1 <- 0.5

sigma <- 3 # standar deviation of the errors
eps <- rnorm(n,mean=0,sd=3) # generate gaussian random errors

# Generate random data
 y <- beta0 + beta1*x  +  eps
```

Plot the data 

```{r,fig.width=8,fig.height=6}
plot(x,y,ylim = c(8,45), cex=1.3, xlab = "x", ylab="y",pch=19)
```


A mathematical procedure for finding the best-fitting curve to a given set of points by minimizing the sum of the squares of the residuals of the points from the fitted line. Illustration of the least squares fit

```{r,echo=FALSE,fig.width=8,fig.height=6}
  sel <- 25
  plot(x, y, xlab = "x", ylab = "y", ylim=c(8,45), cex=.65,pch=19)
   text(x[sel], 8.1, "x=25",cex=2)
   abline(v = x[sel], lty = 2)
    points(x[sel], y[sel], pch = 16, col = "red",cex=1.2)
    text(sel-8, 35,paste("y = ",paste(round(y[sel],2))),cex=2)
    abline(h=y[sel],lty=2)
   lines(x,fitted(lm(y~x)),col="blue",lwd=2)
   points(x[sel],fitted(lm(y~x))[sel],col="blue",lwd=2,pch=15,cex=1.2)
    #text(36, 24,paste("y.hat =", paste(round(fitted(lm(y~x))[sel],2))),cex=2)
   text(36,24,substitute(paste(hat(y),"=",p),list(p=round(fitted(lm(y~x))[sel],2))),cex=2)
   points(cbind(rep(sel,10),seq(y[sel],fitted(lm(y~x))[sel],l=10)),col="grey",t='l',lwd=2,lty=2)
   points(cbind(rep(40,10),seq(y[sel],fitted(lm(y~x))[sel],l=10)),col=1,t='l',lwd=4,lty=1)
   points(cbind(seq(sel,40,l=10),rep(fitted(lm(y~x))[sel],10)),col=1,t='l',lwd=1,lty=2)
   text(46,29, (expression(hat(y)-y)),cex=1.55)
# abline(h = coefficients(lm(y~x))[1],v=0,lty=2)
```




<!-- ```{r, message=FALSE, warning=FALSE} -->
<!-- library(faraway) -->
<!-- data(gala, package = "faraway") -->
<!-- ?gala -->
<!-- head(gala) -->
<!-- lmod <- lm(Species ~ Area + Elevation + Nearest + Scruz + Adjacent, data = gala) -->
<!-- summary(lmod) -->
<!-- ``` -->


For example, in the data set `faithful`, it contains sample data of two random variables named `waiting` and `eruptions`. The `waiting` variable denotes the waiting time until the next eruptions, and `eruptions` denotes the duration. 
```{r}
plot(eruptions~waiting,data=faithful)
```

Its linear regression model can be expressed as: 

$$
Eruptions = \beta_0 + \beta_1*Waiting + \epsilon
$$


If we choose the parameters $\beta_0$ and $\beta_1$ in the simple linear regression model so as to minimize the sum of squares of the error term $\epsilon$. Suppose for the data set `faithful`, we aim to estimate the next eruption duration if the waiting time since the last eruption has been 80 minutes.

We apply the `lm` function to a formula that describes the variable eruptions by the variable waiting, and save the linear regression model in a new variable `eruption.lm`. 

```{r}
data("faithful")
eruption.lm <- lm(eruptions~waiting,data=faithful)
```

Then we extract the parameters of the estimated regression equation with the coefficients function. 
```{r}
coeffs <- coefficients(eruption.lm); coeffs 
```

We now fit the eruption duration using the estimated regression equation.
```{r}
waiting = 80           # the waiting time 
duration = coeffs[1] + coeffs[2]*waiting 
duration 
```

Based on the simple linear regression model, if the waiting time since the last eruption has been 80 minutes, we expect the next one to last `r duration` minutes. 


We wrap the waiting parameter value inside a new data frame named newdata.
```{r}
newdata = data.frame(waiting=80) # wrap the parameter 
```
Then we apply the `predict` function to `eruption.lm` along with `newdata`. 

```{r}
predict(eruption.lm, newdata)    # apply predict 
```


We can directly calculate quantities of interest, i.e. the ordinary least squares solution consists of:

$$
\min_{\beta_0,\beta_1} = \sum_{i=1}^{n} (y_i - \hat{y}_i)^2  
$$

Then
$\hat{\beta}_1  = \frac{\sum_{i=1}^{n}x_iy_i}{\sum_{i=1}^n x_i^2}$ and 
$\hat{\beta}_0 = \bar{y} - \hat{\beta}_1\bar{x}$

In matrix form, with $X=[1:x_1:...:x_p]$

$$
\hat{\beta}  = (X^\prime X)^{-1} X^\prime
$$

where $\hat{\beta} = (\hat{\beta}_0,\hat{\beta}_1)$


## Defining models in `R`

To complete a linear regression using `R` it is first necessary to understand the syntax for defining models.


|     Syntax        |                  Model                    |                               Comments                               |
|:------------------:|:----------------------------------------:|:--------------------------------------------------------------------:|
| `y ~ x`           | $y = \beta_0+\beta_1x$                    | Straight-line with an implicit intercept                             |
| `y ~ -1 + x`      | $y = \beta_1x$                            | Straight-line with no intercept; that is, a fit forced through (0,0) |  
| `y ~ x + I(x^2) ` | $y = \beta_0+\beta_1x+\beta_2x^2$         | Polynomial model; `I()` allows for mathematical symbols              |  
| `y ~ x + z`       | $y = \beta_0+\beta_1x+\beta_2z$           | Multiple regression model                                            |        
| `y ~ x:z`         | $y = \beta_0+\beta_1xz$                   | Model with interaction between $x$ and $z$                           |        
| `y ~ x*z`         | $y = \beta_0+\beta_1x+\beta_2z+\beta_3xz$ | Equivalent to `y~x+z+x:z`                                            |  


In `R` function `model.matrix` helps us to create the $X$ matrix.

```{r}
x <- model.matrix(~waiting, data = faithful)
y <- faithful$eruptions
xtxi <- solve(t(x) %*% x)
betas <- xtxi %*% t(x) %*% y
betas
```

or

```{r}
solve(crossprod(x, x), crossprod(x, y))
```
Of course, it is not necessary here because the `lm()` function does the job but it is very useful when the statistic you want is not part of the pre-packaged functions.


It is possible to get $(X^\prime X)^{-1}$ as
```{r}
summary(eruption.lm)$cov.unscaled
```

The `names()` command is the way to see the components of an `R` object


```{r}
names(eruption.lm)
```

To access for example

- Fitted (or predictd) values ($\hat{y}$):

```{r,eval=FALSE}
eruption.lm$fitted.values
```

- Residuals ($y-\hat{y}$)

```{r,eval=FALSE}
eruption.lm$residuals
```

We can estimate $\sigma$ as $\sigma = \frac{(y_i-\hat{y}_i)^2}{n-p}$ in `R`


```{r}
eruption.lm.sum <- summary(eruption.lm)
names(eruption.lm.sum)

sqrt(deviance(eruption.lm)/df.residual(eruption.lm))
# is obtained directly as
eruption.lm.sum$sigma
```

We may also obtain the standard errors for the coefficients. Also `diag()` returns the diagonal of a
matrix:

```{r}
xtxi 
sqrt(diag(xtxi)) * eruption.lm.sum$sigma

eruption.lm.sum$coef[, 2]
```


## Coefficient of Determination

The **coefficient of determination** of a linear regression model is the quotient of the variances of the fitted values and observed values of the dependent variable. If we denote $y_i$ as the observed values of the dependent variable, $\bar{y}$ as its mean, and $\bar{y}_i$ as the fitted value, then the coefficient of determination is: 
$$
    R^2 = \frac{\sum (\hat{y}_i-\bar{y})^2}{(y_i - \bar{y})^2}
$$

```{r}
summary(eruption.lm)$r.squared 
```

or 
```{r}
1-sum(eruption.lm$res^2)/sum((y-mean(y))^2)
```

More options:

  - `fitted.values()` or  `fitted()` Fitted values of the model

  - `predict()`: to predict $\hat{y}_*$  for new values of $x_*$

  - `confint()`: confidence intervals for model parameters

  - `resid()`: residuals of the model

  - `anova()`: ANOVA table for residuals

  - `deviance()`: deviance of the fitted model, in the LM case is $\sum_i^{n}(\hat{y}_i - y_i)^2$

*See Faraway's (2002) book (Chapters 1-7)*



## Significance Test for Linear Regression

Assume that the error term ?? in the linear regression model is independent of x, and is normally distributed, with zero mean and constant variance. We can decide whether there is any significant relationship between x and y by testing the null hypothesis that $\beta_1 = 0$.


we print out the F-statistics of the significance test with the summary function.
```{r}
summary(eruption.lm) 
```

## Confidence Interval for Linear Regression

Assume that the error term $\epsilon$ in the linear regression model is independent of $x$, and is normally distributed, with zero mean and constant variance. For a given value of $x$, the interval estimate for the mean of the dependent variable, $\bar{y}$ , is called the confidence interval.

A 95% confidence interval of the mean eruption duration for the waiting time of 80 minutes is given by

```{r}
predict(eruption.lm, newdata, interval="confidence") 
```
The 95% confidence interval of the mean eruption duration for the waiting time of 80 minutes is between 4.1048 and 4.2476 minutes. 


##  Prediction Interval for Linear Regression
For a given value of $x$, the interval estimate of the dependent variable $y$ is called the prediction interval. 

```{r}
predict(eruption.lm, newdata, interval="predict") 
```

The 95% prediction interval of the eruption duration for the waiting time of 80 minutes is between 3.1961 and 5.1564 minutes. 


## Residual Plot

The residual data of the simple linear regression model is the difference between the observed data of the dependent variable $y$ and the fitted values $\hat{y}$.

$$
    Residual = y -\hat{y}
$$

```{r}
eruption.res = resid(eruption.lm) 
```


```{r}
plot(faithful$waiting,
    eruption.res, 
    ylab="Residuals", xlab="Waiting Time", 
    main="Old Faithful Eruptions") 
abline(0, 0)
```


## Standardized Residual

The standardized residual is the residual divided by its standard deviation. 

$$
\mbox{Standardized residual}_i =  \frac{Residual_i}{SD.of.Residual_i}
$$

```{r}
eruption.stdres <- rstandard(eruption.lm) 
```

```{r}
plot(faithful$waiting, eruption.stdres, 
      ylab="Standardized Residuals", 
      xlab="Waiting Time", 
      main="Old Faithful Eruptions") 
abline(0, 0)
```




As the p-value is much less than $0.05$, we reject the null hypothesis that $\beta_1 = 0$. Hence there is a significant relationship between the variables in the linear regression model of the data set faithful. 




## Normal Probability Plot of Residuals

The normal probability plot is a graphical tool for comparing a data set with the normal distribution. We can use it with the standardized residual of the linear regression model and see if the error term $\epsilon$ is actually normally distributed. 

```{r}
eruption.lm = lm(eruptions ~ waiting, data=faithful) 
eruption.stdres = rstandard(eruption.lm) 
```

We now create the normal probability plot with the `qqnorm` function, and add the `qqline` for further comparison.

```{r}
 qqnorm(eruption.stdres, 
     ylab="Standardized Residuals", 
     xlab="Normal Scores", 
     main="Old Faithful Eruptions") 
 qqline(eruption.stdres) 
```


## Multiple linear regression

A multiple linear regression (MLR) model that describes a dependent variable $y$ by independent variables $x_1, x_2, ..., x_p$ $(p > 1)$ is expressed by the equation:
$$
    y  = \beta_0 + \sum_{k}^{p} \beta_k + \epsilon
$$
where the numbers $\beta_0$ and $\beta_k$ ($k = 1, 2, ..., p$) are the parameters, and $\epsilon$ is the error term. 



**Example:**

Consider the data `stackloss` from observations of a chemical plant operation, if we assign `stackloss` as the dependent variable, and assign `Air.Flow` (cooling air flow), `Water.Temp` (inlet water temperature) and `Acid.Conc.` (acid concentration) as independent variables, the multiple linear regression model is:

$$
      stack.loss = \beta_0 + \beta_1 * Air.Flow + \beta_2 * Water.Temp + \beta_3 * Acid.Conc + \epsilon
$$

```{r}
data("stackloss")
?stackloss
head(stackloss)
```


Fit the multiple linear regression in `R`

```{r}
stackloss.lm = lm(stack.loss ~ Air.Flow + Water.Temp + Acid.Conc., data=stackloss) 
stackloss.lm
summary(stackloss.lm)
```

Function `termplot` plots regression terms against their predictors:

```{r,fig.width=10,fig.height=10}
?termplot
par(mfrow=c(2,2))
termplot(stackloss.lm, partial.resid = TRUE, se=TRUE,col.se = "blue")
```


**What is the stack loss if the air flow is 72, water temperature is 20 and acid concentration is 85?**

Create a new data frame:

```{r}
newdata <- data.frame(Air.Flow=72,Water.Temp=20,Acid.Conc.=85)
```

Use `predict`

```{r}
predict(stackloss.lm, newdata) 
```

Based on the multiple linear regression model and the given parameters, the predicted stack loss is `r predict(stackloss.lm, newdata)`.


To obtain the multiple coefficient of determination
```{r}
summary(stackloss.lm)$r.squared 
```

### Adjusted coefficient of determination 

The adjusted coefficient of determination of a multiple linear regression model is defined in terms of the coefficient of determination as follows, where $n$ is the number of observations in the data set, and $p$ is the number of independent variables. 


$$
R^2_{adj} = 1-(1-R^2)\frac{n-1}{n-p-1}
$$

```{r}
summary(stackloss.lm)$adj.r.squared 
```

### Significant tests and confidence/prediction intervals

```{r}
summary(stackloss.lm)
```

As the p-values of `Air.Flow` and `Water.Temp` are less than 0.05, they are both statistically significant in the multiple linear regression model of `stackloss`. 

95\% Confidence intervals of the stack loss if the air flow is 72, water temperature is 20 and acid concentration is 85. 

```{r}
predict(stackloss.lm, newdata, interval="confidence")
```

95\% Prediction intervals are

```{r}
predict(stackloss.lm, newdata, interval="prediction")
```



## Linear regression with factor variables

Let us consider the `mtcars` we analyzed previously. In [Section](#population-mean-between-two-independent-samples).

```{r}
data(mtcars)
t.test(mpg ~ am, data=mtcars) 
```

The results from the statistical tests focus on `mpg` and `am` only, without controlling for influences from other variables.

The benefit of regressional analysis serve the purpose. If we apply a multivariate regression to control for certain available design and performance variables, the marginal impact of automatic- or manual- transmission cars does not turn out to be significant. The confounding variables include displacement (disp), rear axle ratio (drat) and car weight(wt). Take car weight for example. The regression suggests that, holding other variables constant (ceteris paribus), maual tramsmitted cars consume on avarage -0.024 more gallons of gas per mile, and the results are no longer statistically significant. Similar analysis work similarily for the other two variables: drat and wt.

```{r}
fit0 <- lm(mpg ~ factor(am), data = mtcars)
summary(fit0)
```



If we apply a multivariate regression to control for certain available design and performance variables, the marginal impact of automatic- or manual- transmission cars does not turn out to be significant. The confounding variables include displacement (`disp`), rear axle ratio (`drat`) and car weight(`wt`). Take car weight for example:

```{r}
fit1 <- lm(mpg ~ factor(am) + wt, data = mtcars)
summary(fit1)
```

The regression suggests that, holding other variables constant, manual tramsmitted cars consume on average `r round(fit1$coefficients[2],3)` more gallons of gas per mile, and the results are no longer statistically significant. Similar analysis work similarily for the other two variables: `drat` and `wt`.

```{r}
fit2 <- lm(mpg ~ factor(am) + drat, data = mtcars)
summary(fit2)

fit3 <- lm(mpg ~ factor(am) + disp, data = mtcars)
summary(fit3)
```

We can use `termplot` 

```{r}
termplot(fit0,partial.resid = TRUE,se=TRUE)
```

```{r}
par(mfrow=c(1,2))
termplot(fit1,partial.resid = TRUE,se=TRUE)
termplot(fit2,partial.resid = TRUE,se=TRUE)
```


## Inference

**Hypothesis test to compare models: the Likelihood ratio test**

A likelihood ratio test is a statistical test used to compare the goodness of fit of two models, one of which (the null model) is a special case of the other (the alternative model). The test is based on the likelihood ratio, which expresses how many times more likely the data are under one model than the other. 

Comparing two models fit to the same data can be set up as a hypothesis testing problem.  Let $M_0$ and $M_1$ denote the models.
Consider as the null hypothesis "$M_1$ is not a significant improvement on $M_0$", and the alternative the negation.  This hypothesis can often be formulated so that a statistic can be generated from the two models.

Normally, the models are nested in that the variables in $M_0$ are a subset of those in $M_1$.  The statistic often involves the $RSS$ (residual sum of squares) values for both models, adjusted by the number of parameters used.  In linear regression this becomes an `anova` test (comparing variances).



More robust is a likelihood ratio test for nested models.  When models are sufficiently specific to define a probability distribution for
$y$, the model will report the log-likelihood, $\hat{L}$.  Under some mild assumptions, $-2(\hat{L}_0 - \hat{L}_1)$ follows a Chi-squared distribution with degrees of freedom = difference in number of parameters on the two models.

The utility of a single model $M_1$ is often assessed by comparing it with the null model, that reflects no dependence of $y$ on the explanatory variables. The model formula for the null model is `y~1`, i.e. we use a constant to approximate `y` (e.g.: the mean of `y`). The likelihood ratio test is implemented in the function `anova`:

```{r}
M0 <- lm(mpg ~ 1, data = mtcars)
M1 <- lm(mpg ~ factor(am), data = mtcars)
summary(M0)
summary(M1)
anova(M0,M1)
```
The likelihood ratio test can also test the significance of predictors. Hence, we can compare the model `fit0` (where `am` is significant) with `fit1`, `fit2` or `fit3`, i.e.:

```{r}
anova(fit0, fit1)
anova(fit0, fit2)
anova(fit0, fit3)
```

However, the likelihood ratio tests suggest that it is important to consider these dimensions (i.e., displacement, rear axle ratio and weight) since these variables increase model fit.




## ANALYSIS-OF-VARIANCE (ANOVA)


In an experiment study, various treatments are applied to test subjects and the response data is gathered for analysis. A critical tool for carrying out the analysis is the Analysis of Variance (ANOVA). It enables a researcher to differentiate treatment results based on easily computed statistical quantities from the treatment outcome.

The statistical process is derived from estimates of the population variances via two separate approaches. The first approach is based on the variance of the sample means, and the second one is based on the mean of the sample variances. Under the ANOVA assumptions as stated below, the ratio of the two statistical estimates follows the F distribution. Hence we can test the null hypothesis on the equality of various response data from different treatments via estimates of critical regions.

    The treatment responses are independent of each other.
    The response data follow the normal distribution.
    The variances of the response data are identical.

In the following tutorials, we demonstrate how to perform ANOVA on a few basic experimental designs. 


```{r}
# Two-way Interaction Plot
data(mtcars)
attach(mtcars)
gear <- factor(gear)
cyl <- factor(cyl)
interaction.plot(cyl, gear, mpg, type="b", col=c(1:3),
   leg.bty="o", leg.bg="beige", lwd=2, pch=c(18,24,22),
   xlab="Number of Cylinders",
   ylab="Mean Miles Per Gallon",
   main="Interaction Plot")
```   
   
```{r}
# Plot Means with Error Bars
library(gplots)
attach(mtcars)
cyl <- factor(cyl)
plotmeans(mpg~cyl,xlab="Number of Cylinders",
  ylab="Miles Per Gallon", main="Mean Plot\nwith 95% CI") 
```



<!-- ```{r, eval=FALSE} -->
<!-- library(faraway) -->
<!-- data(pima, package="faraway") -->
<!-- head(pima) -->
<!-- summary(pima) -->
<!-- sort(pima$diastolic) -->
<!-- pima$diastolic[pima$diastolic == 0]  <- NA -->
<!-- pima$glucose[pima$glucose == 0] <- NA -->
<!-- pima$triceps[pima$triceps == 0]  <- NA -->
<!-- pima$insulin[pima$insulin == 0] <- NA -->
<!-- pima$bmi[pima$bmi == 0] <- NA -->
<!-- pima$test <- factor(pima$test) -->
<!-- summary(pima$test) -->
<!-- levels(pima$test) <- c("negative","positive") -->
<!-- summary(pima) -->
<!-- hist(pima$diastolic,xlab="Diastolic",main="") -->
<!-- plot(density(pima$diastolic,na.rm=TRUE),main="") -->
<!-- plot(sort(pima$diastolic),ylab="Sorted Diastolic") -->
<!-- plot(diabetes ~ diastolic,pima) -->
<!-- plot(diabetes ~ test,pima) -->
<!-- require(ggplot2) -->
<!-- ggplot(pima,aes(x=diastolic))+geom_histogram() -->
<!-- ggplot(pima,aes(x=diastolic))+geom_density() -->
<!-- ggplot(pima,aes(x=diastolic,y=diabetes))+geom_point() -->
<!-- ggplot(pima,aes(x=diastolic,y=diabetes,shape=test))+geom_point()+theme(legend.position = "top", legend.direction = "horizontal") -->
<!-- ggplot(pima,aes(x=diastolic,y=diabetes)) + geom_point(size=1) + facet_grid(~ test) -->
<!-- data(manilius, package="faraway") -->
<!-- head(manilius) -->
<!-- (moon3 <- aggregate(manilius[,1:3],list(manilius$group), sum)) -->
<!-- solve(cbind(9,moon3$sinang,moon3$cosang), moon3$arc) -->
<!-- lmod <- lm(arc ~ sinang + cosang, manilius) -->
<!-- coef(lmod) -->
<!-- data(GaltonFamilies, package="HistData") -->
<!-- plot(childHeight ~ midparentHeight, GaltonFamilies) -->
<!-- lmod <- lm(childHeight ~ midparentHeight, GaltonFamilies) -->
<!-- coef(lmod) -->
<!-- abline(lmod) -->
<!-- (beta <- with(GaltonFamilies, cor(midparentHeight, childHeight) * sd(childHeight) / sd(midparentHeight))) -->
<!-- (alpha <- with(GaltonFamilies, mean(childHeight) - beta * mean(midparentHeight))) -->
<!-- (beta1 <- with(GaltonFamilies, sd(childHeight) / sd(midparentHeight))) -->
<!-- (alpha1 <- with(GaltonFamilies, mean(childHeight) - beta1 * mean(midparentHeight))) -->
<!-- abline(alpha1, beta1, lty=2) -->

<!-- ``` -->

<!-- [link](http://ms.mcmaster.ca/peter/s2ma3/s2ma3_0102/classnotes/notes20020328.html) -->

# Logistic regression 

A logistic regression is typically used when there is one dichotomous outcome variable (such as winning or losing), and a continuous predictor variable which is related to the probability or odds of the outcome variable. It can also be used with categorical predictors, and with multiple predictors. 


## ESR and Plasma Proteins

The erythrocyte sedimentation rate (ESR) is the rate at which red blood cells (erythrocytes) settle out of suspension in blood plasma, when measured under standard conditions. If the ESR increases when the level of certain proteins in the blood plasma rise in association with conditions such as rheumatic diseases, chronic infections and malignant diseases, its determination might be useful in screening blood samples taken from people suspected of suffering from one of the conditions mentioned. The absolute value of the ESR is not of great importance; rather, less than 20mm/hr indicates a "healthy" individual. To assess whether the ESR is a useful diagnostic tool, the question of interest is whether there is any association between the probability of an ESR reading greater than 20mm/hr and the levels of the two plasma proteins. If there is not then the determination of ESR would not be useful for diagnostic purposes. A data frame with 32 observations on the following 3 variables.

  * `fibrinogen` the fibrinogen level in the blood.
  * `globulin`   the globulin level in the blood.
  * `ESR`  the erythrocyte sedimentation rate, either less or greater 20 mm / hour.

```{r}
data("plasma", package = "HSAUR")
head(plasma)
```

```{r}
layout(matrix(1:2, ncol = 2))
boxplot(fibrinogen ~ ESR, data = plasma, varwidth = TRUE, main="Fibrinogen level in the blood")
boxplot(globulin ~ ESR, data = plasma, varwidth = TRUE, main="Globulin level in the blood")
```

The question of interest is whether there is any association between the probability of an ESR reading greater than 20mm/hr and the levels of the two plasma proteins. If there is not then the determination of ESR would not be useful for diagnostic purposes.

Since the response variable is binary, a multiple regression model is not suitable for a regression analysis.

We may write
$$
\mathbb{P}\mbox{r}(y_i=1)=\pi_i \qquad \mathbb{P}\mbox{r}(y_i=0)=1-\pi_i
$$

Normally, we will have a set of covariates $X=(x_1,..., x_p)$ associated with each individual, and our goal will be to investigate the relationship between the response probability $\pi=\pi(X)$ and
the explanatory variables.

So instead of modelling the expected value of the response directly as a linear function of explanatory variables, a suitable transformation is modelled. In this case the most suitable transformation is the logistic or logit function of $\pi$ leading to the model


$$
  \mbox{logit}(\pi) = \mbox{logit}\left(\frac{\pi}{1-\pi}\right) = \beta_0 + \beta_1x_1 + ... + \beta_p x_p
$$

The logit of a probability is simply the log of the odds of the response taking the value one or logit transformation, of p: $logit(p) = \log(p/1-p)$. Logit is sometimes called "log odds." Because of the properties of odds given in the list above, the logit has these properties:

  *  If `odds(y=1s) = 1`, then `logit(p) = 0`.
  *  If `odds(y=1) < 1`, then `logit(p) < 0`.
  *  If `odds(y=1) > 1`, then `logit(p) > 0`.
  
The logit transform fails if p = 0`.

When the response is a binary (dichotomous) variable, and x is numeric, logistic regression fits a logistic curve to the relationship between $x$ and $y$. Hence, logistic regression is linear regression on the logit transform of y, where y is the proportion (or probability) of success at each value of x. However, you should avoid the temptation to do a traditional least-squares regression at this point, as neither the normality nor the homoscedasticity assumption will be met.

```{r}
x <- seq(-6,6,0.01)
logistic <- exp(x)/(1+exp(x))
plot(x,logistic,t='l',main="Logistic curve",ylab="")
abline(h=c(0,0.5,1),v=0,col="grey")
points(0,0.5,pch=19,col=2)
```

Logistic regression model in `R` can be fitted using the function `glm`. First, we start with a model that includes only a single predictor `fibrinogen` 

```{r}
plasma_glm_1 <- glm(ESR ~ fibrinogen, data = plasma,family = binomial())
summary(plasma_glm_1)
```

We see that the regression coefficient for `fibrinogen` is significant at the $5\%$ level. An increase of one unit
in this variable increases the log-odds in favour of an ESR value greater than 20 by an estimated $1.83$ with $95\%$ confidence interval.

```{r}
confint(plasma_glm_1,parm="fibrinogen")
```
These values are more helpful if converted to the corresponding values for the odds themselves by exponentiating the estimate

```{r}
exp(coef(plasma_glm_1)["fibrinogen"])
```
and the confidence interval
```{r}
exp(confint(plasma_glm_1, parm = "fibrinogen"))
```

<!-- ```{r} -->
<!-- layout(matrix(1:2, ncol = 2)) -->
<!-- cdplot(ESR ~ fibrinogen, data = plasma) -->
<!-- cdplot(ESR ~ globulin, data = plasma) -->
<!-- ``` -->


The confidence interval is very wide because there are few observations overall and very few where the ESR value is greater than 20. Nevertheless it seems likely that increased values of fibrinogen lead to a greater probability of an ESR value greater than 20. We can now fit a logistic regression model that includes both explanatory variables using the code

```{r}
plasma_glm_2 <- glm(ESR ~ fibrinogen + globulin, data = plasma,family = binomial())
summary(plasma_glm_2)
```

The coefficient for gamma globulin is not significantly different from zero.

Both nested models can be compared using a likelihood ratio test with `anova` function 
```{r}
anova(plasma_glm_1, plasma_glm_2, test = "Chisq")
```
So we conclude that gamma globulin is not associated with ESR level.


The plot clearly shows the increasing probability of an ESR value above 20 (larger circles) as the values of fibrinogen, and to a
lesser extent, gamma globulin, increase.

```{r}
prob <- predict(plasma_glm_2,type="response")
plot(globulin ~ fibrinogen, data = plasma, xlim = c(2, 6),ylim = c(25, 55), pch = ".")
symbols(plasma$fibrinogen, plasma$globulin, circles = prob,add = TRUE)
```





# Advanced graphics in `R`

## `lattice`

## `ggplot2`

Why `ggplot2`?

Advantages of `ggplot2`

  - consistent underlying grammar of graphics (Wilkinson, 2005)
  - plot specification at a high level of abstraction
  - very flexible
  - theme system for polishing plot appearance
  - mature and complete graphics system
  - many users, active mailing list
  
  
  
  
```{r,message=FALSE,warning=FALSE}
library(ggplot2)
?qplot
qplot(displ, hwy, data = mpg, colour = factor(cyl))
qplot(mpg, wt, data = mtcars)
qplot(mpg, wt, data = mtcars, colour = cyl)
qplot(mpg, wt, data = mtcars, size = cyl)
qplot(mpg, wt, data = mtcars, size = cyl, alpha = I(0.7))
qplot(mpg, wt, data = mtcars, facets = vs ~ am)

qplot(displ, hwy, data=mpg, facets = . ~ year) + geom_smooth()

p <- ggplot(mtcars)
p <- p + aes(wt, hp)
p
p + geom_point(aes(colour = factor(cyl)))

p + geom_point(aes(y = disp))
p

p <- ggplot(mtcars, aes(mpg, wt))
p + geom_point(colour = "darkblue")
```

```{r}
filepath <- "http://idaejin.github.io/bcam-courses/azti-2016/introR/data/ggplot2_data.txt"

myData<-read.table(file=url(filepath),header=TRUE,sep="\t")

str(myData)

qplot(data=myData,x=BM,main="Histogram of BodyMass")

qplot(data=myData,x=BM,y=var1,log="xy",color=Tribe)
```


## Maps

Packages for Spatial Regression / Geostatistics / Spatial Point Pattern methods 

* `sp`, `maptools`, `spatstat`
* `maps`

```{r, message=FALSE,warning=FALSE}
library(maps)
```

Basic syntax

```{r, message=FALSE,warning=FALSE}
map(database = "world",regions=".")
```
Databases are available for US, France, Italy and New Zealand. For other countries, you need to import a database with the corresponding map.

```{r, message=FALSE,warning=FALSE}
map(database = "usa")
map("state")
```

With the package `RgoogleMaps`, you can draw a background from Google Maps! 

```{r,message=FALSE,warning=FALSE}
require(RgoogleMaps)
lat <- 43.073888
lon <- -89.405236
center <- c(lat, lon)
zoom <- 18
MyMap <- GetMap(center=center, zoom=zoom)
PlotOnStaticMap(MyMap)
text(lat,lon, "X") # I missed the class!
```

`ggmap` offers plotting capabilities like `ggplot2`

```{r,message=FALSE,warning=FALSE}
require(ggmap)
geocode("Union South, Madison, WI")
```

# Case studies


## The Forbes 2000 Ranking of the World's Biggest Companies (Year 2004)

The data handling and manipulation techniques explained will be illustrated by means of a data set of 2000 world leading companies, the Forbes 2000 list for the year 2004 collected by Forbes Magazine. This list is originally available from `www.forbes.com`

Here we show a subset of the data set:

```{r,echo=TRUE,message=FALSE,warning=FALSE}
library("HSAUR2")
data("Forbes2000")
```
```{r,echo=FALSE}
library(knitr)
kable(head(Forbes2000))
```

The data consists of 2000 observations on the following 8 variables.
    
  * `rank`: the ranking of the company.
  * `name`: the name of the company.
  * `country`: a factor giving the country the company is situated in.
  * `category`: a factor describing the products the company produces.
  * `sales`: the amount of sales of the company in billion USD.
  * `profits`: the profit of the company in billion USD. 
  * `assets`: the assets of the company in billion USD.
  * `marketvalue`: the market value of the company in billion USD.
    
**Types of variables**

`R` command

```{r,echo=TRUE}
str(Forbes2000)
```

**Factor levels**

Nominal measurements are represented by factor variables in `R`, such as the country of the company or the category of the business segment.

A factor in `R` is divided into levels



How many countries are on the top 2000 ranking?

`R` command


```{r,echo=TRUE}
nlevels(Forbes2000[,"country"])
```

Which countries?

`R` command

```{r,echo=TRUE}
levels(Forbes2000[,"country"])
```

And in the top 20?

`R` commands

```{r,echo=TRUE}
top20 <- droplevels(subset(Forbes2000,rank<=20))
levels(top20[,"country"])
```

As a simple summary statistic, the frequencies of the levels of such a factor variable can be found from

```{r,echo=TRUE}
table(top20[,"country"])
```


Which type of companies?

```{r,echo=TRUE}
levels(Forbes2000[,"category"])
```

How many of each category?

```{r,echo=TRUE}
table(Forbes2000[,"category"])
```

A simple summary statistics such as the mean, median, quantiles and range can be found from continuous variables such as `sales`

`R` command

```{r,echo=TRUE}
summary(Forbes2000[,"sales"])
```

**Simple Graphics**

*Chambers et al. (1983)*, "there is no statistical tool that is as powerful as a well chosen graph"


Histograms and boxplots

```{r,echo=TRUE,fig.width=12,fig.height=10}
layout(matrix(1:4, nrow = 2,ncol=2))
hist(Forbes2000$marketvalue, col="lightgrey",main="Histogram of market value")
hist(log(Forbes2000$marketvalue),col="lightgrey",main="Histogram of log(market value)")
boxplot(Forbes2000$marketvalue, col="lightgrey",main="Boxplot of market value")
boxplot(log(Forbes2000$marketvalue),col="lightgrey",main="Boxplot of log(market value)")
```

Scatterplots to visualize the relationship betwen variables


```{r,echo=FALSE,fig.width=12,fig.height=10}
layout(matrix(1:2, nrow = 2))
plot(marketvalue ~ sales, data = Forbes2000, pch = ".")
plot(log(marketvalue) ~ log(sales), data = Forbes2000, pch = ".")
```

**Cool Graphics**

Using the `ggplot2` library

```{r,message=FALSE,warning=FALSE}
library(ggplot2)
#?qplot
qplot(marketvalue,data = Forbes2000)
qplot(log(marketvalue),  data = Forbes2000)
qplot(marketvalue,sales, data=Forbes2000)
qplot(log(marketvalue),log(sales),size=assets,alpha = I(0.1),data=Forbes2000)
```


```{r,echo=TRUE,message=FALSE,warning=FALSE}
library(calibrate)
profits_all = na.omit(Forbes2000$profits)  # all_profts without No data
order_profits = order(profits_all)     # index of the profitable companies in decreasing order
top_50 = rev(order_profits)[1:50]      # top 50 profitable companies

sales = Forbes2000$sales[top_50]       # sales of the 50 top profitable companies
assets = Forbes2000$assets[top_50]     # assets of the 50 top profitable companies
countries = Forbes2000$country[top_50] # countries where the 50 top profitable companies are found

plot(assets,sales,pch =1)
textxy(assets,sales, abbreviate(countries,2),col = "blue",cex=0.5)  # used to put the countries where the companies are found
title(main = "Sales and Assets in billion USD \n of the 50 most profitable companies ", col.main = "gray")
```

**Graphics by factor**

Boxplots of the logarithms of the market value for four selected countries, the width of the boxes is proportional to the square roots of the number of companies.

```{r, echo=TRUE}
tmp <- subset(Forbes2000,
        country %in% c("United Kingdom", "Germany",
                       "India", "Turkey"))
tmp$country <- tmp$country[,drop = TRUE]
plot(log(marketvalue) ~ country, data = tmp, col = 3:6,
       ylab = "log(marketvalue)", varwidth = TRUE)
```

Scatterplots by country

```{r,echo=TRUE, warning=FALSE}
library(lattice)
xyplot(log(marketvalue)~log(sales)|country,data=tmp)
```

<!-- ## Questions -->


<!--   1. Calculate the median profit for the companies in the US and the median profit for the companies in the UK, France and Germany. -->
<!--   2. Find all German companies with negative profit. -->
<!--   3. To which business category do most of the Bermuda island companies belong? -->
<!--   4. For the 50 companies in the Forbes data set with the highest profits, plot sales against assets (or some suitable transformation of each variable), labelling each point with the appropriate country name which may need to be abbreviated (using abbreviate) to avoid making the plot look too "messy". -->
<!--   5. Find the average value of sales for the companies in each country in the Forbes data set, and find the number of companies in each country with profits above 5 billion US dollars. -->

 
-----------------------------------------


## Malignant Melanoma in the USA

Fisher and Belle (1993) report mortality rates due to malignant melanoma of the skin for white males during the period 1950-1969, for each state on the US mainland. 


```{r,echo=TRUE}
data("USmelanoma",package="HSAUR2")
```

A data consists of 48 observations on the following 5 variables.

  * `mortality`: number of white males died due to malignant melanoma 1950-1969 per one million inhabitants.

  * `latitude`: latitude of the geographic centre of the state.

  * `longitude`: longitude of the geographic centre of each state.

  * `ocean`: a binary variable indicating contiguity to an ocean at levels `no` or `yes`.


**Plotting mortality rates**

```{r}
xr <- range(USmelanoma$mortality) * c(0.9, 1.1)
```

Let us plot mortality rates in 

```{r,fig.align='center',echo=TRUE}
#layout(matrix(1:2, nrow = 2))
boxplot(USmelanoma$mortality, ylim = xr, horizontal = TRUE,xlab = "Mortality")
hist(USmelanoma$mortality, xlim = xr, xlab = "", main = "",axes = FALSE, ylab = "")
axis(1)
```

Malignant melanoma mortality rates by contiguity to an ocean

```{r,fig.align='center'}
plot(mortality ~ ocean, data = USmelanoma, xlab = "Contiguity to an ocean", ylab = "Mortality")
```

Histograms can often be misleading for displaying distributions because of their dependence on the number of classes chosen. An alternative is to formally estimate the density function of a variable and then plot the resulting estimate.

The estimated densities of malignant melanoma mortality rates by contiguity to an ocean looks like this:

```{r,echo=TRUE,fig.width=12,fig.height=10,fig.align='center'}
dyes <- with(USmelanoma, density(mortality[ocean == "yes"]))
dno <- with(USmelanoma, density(mortality[ocean == "no"]))
plot(dyes, lty = 1, xlim = xr, main = "", ylim = c(0, 0.018))
lines(dno, lty = 2)
legend("topright", lty = 1:2, legend = c("Coastal State","Land State"), bty = "n")
```


Now we might move on to look at how mortality rates are related to the geographic location of a state as represented by the latitude and longitude of the centre of the state. 

```{r,echo=TRUE,fig.align='center'}
layout(matrix(1:2, ncol = 2))
plot(mortality ~ -longitude, data = USmelanoma)
plot(mortality ~ latitude, data = USmelanoma)
```

## Mapping mortality rates

The data contains the longitude and latitude of the centroids 

```{r,echo=TRUE,fig.align='center',message=FALSE,warning=FALSE}
plot(-USmelanoma$longitude,USmelanoma$latitude,asp=1.5,cex=.3,pch=19,col="blue")
```


```{r,echo=TRUE,fig.align='center',message=FALSE,warning=FALSE}
library("sp")
library("maps")
library("maptools")
library("RColorBrewer")
map("state")
points(-USmelanoma$longitude,USmelanoma$latitude,asp=1.5,cex=.3,pch=19,col="blue")
```

```{r,fig.align='center',message=FALSE,warning=FALSE,echo=TRUE}
#Create a function to generate a continuous color palette
rbPal <- colorRampPalette(c('blue','grey','red'))
#This adds a column of color values
# based on the y values
USmelanoma$Col <- (rbPal(10)[as.numeric(cut(USmelanoma$mortality,breaks = 10))])
map("state",xlim=c(-135,-65))
points(-USmelanoma$longitude,USmelanoma$latitude,col=USmelanoma$Col,asp=1.5,pch=19,cex=1.2)
legend("topleft",title="Decile",legend=quantile(USmelanoma$mortality,seq(0.1,1,l=10)),col =rbPal(10),pch=15,cex=1.,box.col = NA)
```

```{r,fig.width=12,fig.height=10,fig.align='center',message=FALSE,warning=FALSE,echo=TRUE}
states <- map("state", plot = FALSE, fill = TRUE)
IDs <- sapply(strsplit(states$names, ":"), function(x) x[1])
rownames(USmelanoma) <- tolower(rownames(USmelanoma))

us1 <- map2SpatialPolygons(states, IDs=IDs,proj4string = CRS("+proj=longlat +datum=WGS84"))
us2 <- SpatialPolygonsDataFrame(us1, USmelanoma)

col <- colorRampPalette(c('blue', 'gray80','red'))

spplot(us2, "mortality", col.regions = col(200),par.settings = list(axis.line = list(col =  'transparent')),main="Map of the US showing malignant melanoma mortality rates")
```



```{r,eval=FALSE,echo=FALSE,message=FALSE}
library(knitr)
purl("IntroSM.Rmd",output="IntroSM.R")
```


